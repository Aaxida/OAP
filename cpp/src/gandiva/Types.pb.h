// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: Types.proto

#ifndef PROTOBUF_INCLUDED_Types_2eproto
#define PROTOBUF_INCLUDED_Types_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3007000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3007001 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_Types_2eproto

// Internal implementation detail -- do not use these members.
struct TableStruct_Types_2eproto {
  static const ::google::protobuf::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::ParseTable schema[29]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors_Types_2eproto();
namespace types {
class AndNode;
class AndNodeDefaultTypeInternal;
extern AndNodeDefaultTypeInternal _AndNode_default_instance_;
class BinaryConstants;
class BinaryConstantsDefaultTypeInternal;
extern BinaryConstantsDefaultTypeInternal _BinaryConstants_default_instance_;
class BinaryNode;
class BinaryNodeDefaultTypeInternal;
extern BinaryNodeDefaultTypeInternal _BinaryNode_default_instance_;
class BooleanNode;
class BooleanNodeDefaultTypeInternal;
extern BooleanNodeDefaultTypeInternal _BooleanNode_default_instance_;
class Condition;
class ConditionDefaultTypeInternal;
extern ConditionDefaultTypeInternal _Condition_default_instance_;
class DecimalNode;
class DecimalNodeDefaultTypeInternal;
extern DecimalNodeDefaultTypeInternal _DecimalNode_default_instance_;
class DoubleNode;
class DoubleNodeDefaultTypeInternal;
extern DoubleNodeDefaultTypeInternal _DoubleNode_default_instance_;
class ExpressionList;
class ExpressionListDefaultTypeInternal;
extern ExpressionListDefaultTypeInternal _ExpressionList_default_instance_;
class ExpressionRoot;
class ExpressionRootDefaultTypeInternal;
extern ExpressionRootDefaultTypeInternal _ExpressionRoot_default_instance_;
class ExtGandivaType;
class ExtGandivaTypeDefaultTypeInternal;
extern ExtGandivaTypeDefaultTypeInternal _ExtGandivaType_default_instance_;
class Field;
class FieldDefaultTypeInternal;
extern FieldDefaultTypeInternal _Field_default_instance_;
class FieldNode;
class FieldNodeDefaultTypeInternal;
extern FieldNodeDefaultTypeInternal _FieldNode_default_instance_;
class FloatNode;
class FloatNodeDefaultTypeInternal;
extern FloatNodeDefaultTypeInternal _FloatNode_default_instance_;
class FunctionNode;
class FunctionNodeDefaultTypeInternal;
extern FunctionNodeDefaultTypeInternal _FunctionNode_default_instance_;
class FunctionSignature;
class FunctionSignatureDefaultTypeInternal;
extern FunctionSignatureDefaultTypeInternal _FunctionSignature_default_instance_;
class GandivaDataTypes;
class GandivaDataTypesDefaultTypeInternal;
extern GandivaDataTypesDefaultTypeInternal _GandivaDataTypes_default_instance_;
class GandivaFunctions;
class GandivaFunctionsDefaultTypeInternal;
extern GandivaFunctionsDefaultTypeInternal _GandivaFunctions_default_instance_;
class IfNode;
class IfNodeDefaultTypeInternal;
extern IfNodeDefaultTypeInternal _IfNode_default_instance_;
class InNode;
class InNodeDefaultTypeInternal;
extern InNodeDefaultTypeInternal _InNode_default_instance_;
class IntConstants;
class IntConstantsDefaultTypeInternal;
extern IntConstantsDefaultTypeInternal _IntConstants_default_instance_;
class IntNode;
class IntNodeDefaultTypeInternal;
extern IntNodeDefaultTypeInternal _IntNode_default_instance_;
class LongConstants;
class LongConstantsDefaultTypeInternal;
extern LongConstantsDefaultTypeInternal _LongConstants_default_instance_;
class LongNode;
class LongNodeDefaultTypeInternal;
extern LongNodeDefaultTypeInternal _LongNode_default_instance_;
class NullNode;
class NullNodeDefaultTypeInternal;
extern NullNodeDefaultTypeInternal _NullNode_default_instance_;
class OrNode;
class OrNodeDefaultTypeInternal;
extern OrNodeDefaultTypeInternal _OrNode_default_instance_;
class Schema;
class SchemaDefaultTypeInternal;
extern SchemaDefaultTypeInternal _Schema_default_instance_;
class StringConstants;
class StringConstantsDefaultTypeInternal;
extern StringConstantsDefaultTypeInternal _StringConstants_default_instance_;
class StringNode;
class StringNodeDefaultTypeInternal;
extern StringNodeDefaultTypeInternal _StringNode_default_instance_;
class TreeNode;
class TreeNodeDefaultTypeInternal;
extern TreeNodeDefaultTypeInternal _TreeNode_default_instance_;
}  // namespace types
namespace google {
namespace protobuf {
template<> ::types::AndNode* Arena::CreateMaybeMessage<::types::AndNode>(Arena*);
template<> ::types::BinaryConstants* Arena::CreateMaybeMessage<::types::BinaryConstants>(Arena*);
template<> ::types::BinaryNode* Arena::CreateMaybeMessage<::types::BinaryNode>(Arena*);
template<> ::types::BooleanNode* Arena::CreateMaybeMessage<::types::BooleanNode>(Arena*);
template<> ::types::Condition* Arena::CreateMaybeMessage<::types::Condition>(Arena*);
template<> ::types::DecimalNode* Arena::CreateMaybeMessage<::types::DecimalNode>(Arena*);
template<> ::types::DoubleNode* Arena::CreateMaybeMessage<::types::DoubleNode>(Arena*);
template<> ::types::ExpressionList* Arena::CreateMaybeMessage<::types::ExpressionList>(Arena*);
template<> ::types::ExpressionRoot* Arena::CreateMaybeMessage<::types::ExpressionRoot>(Arena*);
template<> ::types::ExtGandivaType* Arena::CreateMaybeMessage<::types::ExtGandivaType>(Arena*);
template<> ::types::Field* Arena::CreateMaybeMessage<::types::Field>(Arena*);
template<> ::types::FieldNode* Arena::CreateMaybeMessage<::types::FieldNode>(Arena*);
template<> ::types::FloatNode* Arena::CreateMaybeMessage<::types::FloatNode>(Arena*);
template<> ::types::FunctionNode* Arena::CreateMaybeMessage<::types::FunctionNode>(Arena*);
template<> ::types::FunctionSignature* Arena::CreateMaybeMessage<::types::FunctionSignature>(Arena*);
template<> ::types::GandivaDataTypes* Arena::CreateMaybeMessage<::types::GandivaDataTypes>(Arena*);
template<> ::types::GandivaFunctions* Arena::CreateMaybeMessage<::types::GandivaFunctions>(Arena*);
template<> ::types::IfNode* Arena::CreateMaybeMessage<::types::IfNode>(Arena*);
template<> ::types::InNode* Arena::CreateMaybeMessage<::types::InNode>(Arena*);
template<> ::types::IntConstants* Arena::CreateMaybeMessage<::types::IntConstants>(Arena*);
template<> ::types::IntNode* Arena::CreateMaybeMessage<::types::IntNode>(Arena*);
template<> ::types::LongConstants* Arena::CreateMaybeMessage<::types::LongConstants>(Arena*);
template<> ::types::LongNode* Arena::CreateMaybeMessage<::types::LongNode>(Arena*);
template<> ::types::NullNode* Arena::CreateMaybeMessage<::types::NullNode>(Arena*);
template<> ::types::OrNode* Arena::CreateMaybeMessage<::types::OrNode>(Arena*);
template<> ::types::Schema* Arena::CreateMaybeMessage<::types::Schema>(Arena*);
template<> ::types::StringConstants* Arena::CreateMaybeMessage<::types::StringConstants>(Arena*);
template<> ::types::StringNode* Arena::CreateMaybeMessage<::types::StringNode>(Arena*);
template<> ::types::TreeNode* Arena::CreateMaybeMessage<::types::TreeNode>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace types {

enum GandivaType {
  NONE = 0,
  BOOL = 1,
  UINT8 = 2,
  INT8 = 3,
  UINT16 = 4,
  INT16 = 5,
  UINT32 = 6,
  INT32 = 7,
  UINT64 = 8,
  INT64 = 9,
  HALF_FLOAT = 10,
  FLOAT = 11,
  DOUBLE = 12,
  UTF8 = 13,
  BINARY = 14,
  FIXED_SIZE_BINARY = 15,
  DATE32 = 16,
  DATE64 = 17,
  TIMESTAMP = 18,
  TIME32 = 19,
  TIME64 = 20,
  INTERVAL = 21,
  DECIMAL = 22,
  LIST = 23,
  STRUCT = 24,
  UNION = 25,
  DICTIONARY = 26,
  MAP = 27
};
bool GandivaType_IsValid(int value);
const GandivaType GandivaType_MIN = NONE;
const GandivaType GandivaType_MAX = MAP;
const int GandivaType_ARRAYSIZE = GandivaType_MAX + 1;

const ::google::protobuf::EnumDescriptor* GandivaType_descriptor();
inline const ::std::string& GandivaType_Name(GandivaType value) {
  return ::google::protobuf::internal::NameOfEnum(
    GandivaType_descriptor(), value);
}
inline bool GandivaType_Parse(
    const ::std::string& name, GandivaType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<GandivaType>(
    GandivaType_descriptor(), name, value);
}
enum DateUnit {
  DAY = 0,
  MILLI = 1
};
bool DateUnit_IsValid(int value);
const DateUnit DateUnit_MIN = DAY;
const DateUnit DateUnit_MAX = MILLI;
const int DateUnit_ARRAYSIZE = DateUnit_MAX + 1;

const ::google::protobuf::EnumDescriptor* DateUnit_descriptor();
inline const ::std::string& DateUnit_Name(DateUnit value) {
  return ::google::protobuf::internal::NameOfEnum(
    DateUnit_descriptor(), value);
}
inline bool DateUnit_Parse(
    const ::std::string& name, DateUnit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<DateUnit>(
    DateUnit_descriptor(), name, value);
}
enum TimeUnit {
  SEC = 0,
  MILLISEC = 1,
  MICROSEC = 2,
  NANOSEC = 3
};
bool TimeUnit_IsValid(int value);
const TimeUnit TimeUnit_MIN = SEC;
const TimeUnit TimeUnit_MAX = NANOSEC;
const int TimeUnit_ARRAYSIZE = TimeUnit_MAX + 1;

const ::google::protobuf::EnumDescriptor* TimeUnit_descriptor();
inline const ::std::string& TimeUnit_Name(TimeUnit value) {
  return ::google::protobuf::internal::NameOfEnum(
    TimeUnit_descriptor(), value);
}
inline bool TimeUnit_Parse(
    const ::std::string& name, TimeUnit* value) {
  return ::google::protobuf::internal::ParseNamedEnum<TimeUnit>(
    TimeUnit_descriptor(), name, value);
}
enum SelectionVectorType {
  SV_NONE = 0,
  SV_INT16 = 1,
  SV_INT32 = 2
};
bool SelectionVectorType_IsValid(int value);
const SelectionVectorType SelectionVectorType_MIN = SV_NONE;
const SelectionVectorType SelectionVectorType_MAX = SV_INT32;
const int SelectionVectorType_ARRAYSIZE = SelectionVectorType_MAX + 1;

const ::google::protobuf::EnumDescriptor* SelectionVectorType_descriptor();
inline const ::std::string& SelectionVectorType_Name(SelectionVectorType value) {
  return ::google::protobuf::internal::NameOfEnum(
    SelectionVectorType_descriptor(), value);
}
inline bool SelectionVectorType_Parse(
    const ::std::string& name, SelectionVectorType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<SelectionVectorType>(
    SelectionVectorType_descriptor(), name, value);
}
// ===================================================================

class ExtGandivaType :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.ExtGandivaType) */ {
 public:
  ExtGandivaType();
  virtual ~ExtGandivaType();

  ExtGandivaType(const ExtGandivaType& from);

  inline ExtGandivaType& operator=(const ExtGandivaType& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExtGandivaType(ExtGandivaType&& from) noexcept
    : ExtGandivaType() {
    *this = ::std::move(from);
  }

  inline ExtGandivaType& operator=(ExtGandivaType&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ExtGandivaType& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExtGandivaType* internal_default_instance() {
    return reinterpret_cast<const ExtGandivaType*>(
               &_ExtGandivaType_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(ExtGandivaType* other);
  friend void swap(ExtGandivaType& a, ExtGandivaType& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExtGandivaType* New() const final {
    return CreateMaybeMessage<ExtGandivaType>(nullptr);
  }

  ExtGandivaType* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExtGandivaType>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExtGandivaType& from);
  void MergeFrom(const ExtGandivaType& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExtGandivaType* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string timeZone = 7;
  bool has_timezone() const;
  void clear_timezone();
  static const int kTimeZoneFieldNumber = 7;
  const ::std::string& timezone() const;
  void set_timezone(const ::std::string& value);
  #if LANG_CXX11
  void set_timezone(::std::string&& value);
  #endif
  void set_timezone(const char* value);
  void set_timezone(const char* value, size_t size);
  ::std::string* mutable_timezone();
  ::std::string* release_timezone();
  void set_allocated_timezone(::std::string* timezone);

  // optional .types.GandivaType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::types::GandivaType type() const;
  void set_type(::types::GandivaType value);

  // optional uint32 width = 2;
  bool has_width() const;
  void clear_width();
  static const int kWidthFieldNumber = 2;
  ::google::protobuf::uint32 width() const;
  void set_width(::google::protobuf::uint32 value);

  // optional int32 precision = 3;
  bool has_precision() const;
  void clear_precision();
  static const int kPrecisionFieldNumber = 3;
  ::google::protobuf::int32 precision() const;
  void set_precision(::google::protobuf::int32 value);

  // optional int32 scale = 4;
  bool has_scale() const;
  void clear_scale();
  static const int kScaleFieldNumber = 4;
  ::google::protobuf::int32 scale() const;
  void set_scale(::google::protobuf::int32 value);

  // optional .types.DateUnit dateUnit = 5;
  bool has_dateunit() const;
  void clear_dateunit();
  static const int kDateUnitFieldNumber = 5;
  ::types::DateUnit dateunit() const;
  void set_dateunit(::types::DateUnit value);

  // optional .types.TimeUnit timeUnit = 6;
  bool has_timeunit() const;
  void clear_timeunit();
  static const int kTimeUnitFieldNumber = 6;
  ::types::TimeUnit timeunit() const;
  void set_timeunit(::types::TimeUnit value);

  // @@protoc_insertion_point(class_scope:types.ExtGandivaType)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr timezone_;
  int type_;
  ::google::protobuf::uint32 width_;
  ::google::protobuf::int32 precision_;
  ::google::protobuf::int32 scale_;
  int dateunit_;
  int timeunit_;
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class Field :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.Field) */ {
 public:
  Field();
  virtual ~Field();

  Field(const Field& from);

  inline Field& operator=(const Field& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Field(Field&& from) noexcept
    : Field() {
    *this = ::std::move(from);
  }

  inline Field& operator=(Field&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Field& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Field* internal_default_instance() {
    return reinterpret_cast<const Field*>(
               &_Field_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(Field* other);
  friend void swap(Field& a, Field& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Field* New() const final {
    return CreateMaybeMessage<Field>(nullptr);
  }

  Field* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Field>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Field& from);
  void MergeFrom(const Field& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Field* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .types.Field children = 4;
  int children_size() const;
  void clear_children();
  static const int kChildrenFieldNumber = 4;
  ::types::Field* mutable_children(int index);
  ::google::protobuf::RepeatedPtrField< ::types::Field >*
      mutable_children();
  const ::types::Field& children(int index) const;
  ::types::Field* add_children();
  const ::google::protobuf::RepeatedPtrField< ::types::Field >&
      children() const;

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .types.ExtGandivaType type = 2;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 2;
  const ::types::ExtGandivaType& type() const;
  ::types::ExtGandivaType* release_type();
  ::types::ExtGandivaType* mutable_type();
  void set_allocated_type(::types::ExtGandivaType* type);

  // optional bool nullable = 3;
  bool has_nullable() const;
  void clear_nullable();
  static const int kNullableFieldNumber = 3;
  bool nullable() const;
  void set_nullable(bool value);

  // @@protoc_insertion_point(class_scope:types.Field)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::types::Field > children_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::types::ExtGandivaType* type_;
  bool nullable_;
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class FieldNode :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.FieldNode) */ {
 public:
  FieldNode();
  virtual ~FieldNode();

  FieldNode(const FieldNode& from);

  inline FieldNode& operator=(const FieldNode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FieldNode(FieldNode&& from) noexcept
    : FieldNode() {
    *this = ::std::move(from);
  }

  inline FieldNode& operator=(FieldNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FieldNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FieldNode* internal_default_instance() {
    return reinterpret_cast<const FieldNode*>(
               &_FieldNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(FieldNode* other);
  friend void swap(FieldNode& a, FieldNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FieldNode* New() const final {
    return CreateMaybeMessage<FieldNode>(nullptr);
  }

  FieldNode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FieldNode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FieldNode& from);
  void MergeFrom(const FieldNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FieldNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .types.Field field = 1;
  bool has_field() const;
  void clear_field();
  static const int kFieldFieldNumber = 1;
  const ::types::Field& field() const;
  ::types::Field* release_field();
  ::types::Field* mutable_field();
  void set_allocated_field(::types::Field* field);

  // @@protoc_insertion_point(class_scope:types.FieldNode)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::types::Field* field_;
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class FunctionNode :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.FunctionNode) */ {
 public:
  FunctionNode();
  virtual ~FunctionNode();

  FunctionNode(const FunctionNode& from);

  inline FunctionNode& operator=(const FunctionNode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FunctionNode(FunctionNode&& from) noexcept
    : FunctionNode() {
    *this = ::std::move(from);
  }

  inline FunctionNode& operator=(FunctionNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FunctionNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FunctionNode* internal_default_instance() {
    return reinterpret_cast<const FunctionNode*>(
               &_FunctionNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(FunctionNode* other);
  friend void swap(FunctionNode& a, FunctionNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FunctionNode* New() const final {
    return CreateMaybeMessage<FunctionNode>(nullptr);
  }

  FunctionNode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FunctionNode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FunctionNode& from);
  void MergeFrom(const FunctionNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FunctionNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .types.TreeNode inArgs = 2;
  int inargs_size() const;
  void clear_inargs();
  static const int kInArgsFieldNumber = 2;
  ::types::TreeNode* mutable_inargs(int index);
  ::google::protobuf::RepeatedPtrField< ::types::TreeNode >*
      mutable_inargs();
  const ::types::TreeNode& inargs(int index) const;
  ::types::TreeNode* add_inargs();
  const ::google::protobuf::RepeatedPtrField< ::types::TreeNode >&
      inargs() const;

  // optional string functionName = 1;
  bool has_functionname() const;
  void clear_functionname();
  static const int kFunctionNameFieldNumber = 1;
  const ::std::string& functionname() const;
  void set_functionname(const ::std::string& value);
  #if LANG_CXX11
  void set_functionname(::std::string&& value);
  #endif
  void set_functionname(const char* value);
  void set_functionname(const char* value, size_t size);
  ::std::string* mutable_functionname();
  ::std::string* release_functionname();
  void set_allocated_functionname(::std::string* functionname);

  // optional .types.ExtGandivaType returnType = 3;
  bool has_returntype() const;
  void clear_returntype();
  static const int kReturnTypeFieldNumber = 3;
  const ::types::ExtGandivaType& returntype() const;
  ::types::ExtGandivaType* release_returntype();
  ::types::ExtGandivaType* mutable_returntype();
  void set_allocated_returntype(::types::ExtGandivaType* returntype);

  // @@protoc_insertion_point(class_scope:types.FunctionNode)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::types::TreeNode > inargs_;
  ::google::protobuf::internal::ArenaStringPtr functionname_;
  ::types::ExtGandivaType* returntype_;
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class IfNode :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.IfNode) */ {
 public:
  IfNode();
  virtual ~IfNode();

  IfNode(const IfNode& from);

  inline IfNode& operator=(const IfNode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IfNode(IfNode&& from) noexcept
    : IfNode() {
    *this = ::std::move(from);
  }

  inline IfNode& operator=(IfNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const IfNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IfNode* internal_default_instance() {
    return reinterpret_cast<const IfNode*>(
               &_IfNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(IfNode* other);
  friend void swap(IfNode& a, IfNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IfNode* New() const final {
    return CreateMaybeMessage<IfNode>(nullptr);
  }

  IfNode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IfNode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IfNode& from);
  void MergeFrom(const IfNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IfNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .types.TreeNode cond = 1;
  bool has_cond() const;
  void clear_cond();
  static const int kCondFieldNumber = 1;
  const ::types::TreeNode& cond() const;
  ::types::TreeNode* release_cond();
  ::types::TreeNode* mutable_cond();
  void set_allocated_cond(::types::TreeNode* cond);

  // optional .types.TreeNode thenNode = 2;
  bool has_thennode() const;
  void clear_thennode();
  static const int kThenNodeFieldNumber = 2;
  const ::types::TreeNode& thennode() const;
  ::types::TreeNode* release_thennode();
  ::types::TreeNode* mutable_thennode();
  void set_allocated_thennode(::types::TreeNode* thennode);

  // optional .types.TreeNode elseNode = 3;
  bool has_elsenode() const;
  void clear_elsenode();
  static const int kElseNodeFieldNumber = 3;
  const ::types::TreeNode& elsenode() const;
  ::types::TreeNode* release_elsenode();
  ::types::TreeNode* mutable_elsenode();
  void set_allocated_elsenode(::types::TreeNode* elsenode);

  // optional .types.ExtGandivaType returnType = 4;
  bool has_returntype() const;
  void clear_returntype();
  static const int kReturnTypeFieldNumber = 4;
  const ::types::ExtGandivaType& returntype() const;
  ::types::ExtGandivaType* release_returntype();
  ::types::ExtGandivaType* mutable_returntype();
  void set_allocated_returntype(::types::ExtGandivaType* returntype);

  // @@protoc_insertion_point(class_scope:types.IfNode)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::types::TreeNode* cond_;
  ::types::TreeNode* thennode_;
  ::types::TreeNode* elsenode_;
  ::types::ExtGandivaType* returntype_;
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class AndNode :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.AndNode) */ {
 public:
  AndNode();
  virtual ~AndNode();

  AndNode(const AndNode& from);

  inline AndNode& operator=(const AndNode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AndNode(AndNode&& from) noexcept
    : AndNode() {
    *this = ::std::move(from);
  }

  inline AndNode& operator=(AndNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const AndNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AndNode* internal_default_instance() {
    return reinterpret_cast<const AndNode*>(
               &_AndNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    5;

  void Swap(AndNode* other);
  friend void swap(AndNode& a, AndNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AndNode* New() const final {
    return CreateMaybeMessage<AndNode>(nullptr);
  }

  AndNode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AndNode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AndNode& from);
  void MergeFrom(const AndNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AndNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .types.TreeNode args = 1;
  int args_size() const;
  void clear_args();
  static const int kArgsFieldNumber = 1;
  ::types::TreeNode* mutable_args(int index);
  ::google::protobuf::RepeatedPtrField< ::types::TreeNode >*
      mutable_args();
  const ::types::TreeNode& args(int index) const;
  ::types::TreeNode* add_args();
  const ::google::protobuf::RepeatedPtrField< ::types::TreeNode >&
      args() const;

  // @@protoc_insertion_point(class_scope:types.AndNode)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::types::TreeNode > args_;
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class OrNode :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.OrNode) */ {
 public:
  OrNode();
  virtual ~OrNode();

  OrNode(const OrNode& from);

  inline OrNode& operator=(const OrNode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  OrNode(OrNode&& from) noexcept
    : OrNode() {
    *this = ::std::move(from);
  }

  inline OrNode& operator=(OrNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const OrNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const OrNode* internal_default_instance() {
    return reinterpret_cast<const OrNode*>(
               &_OrNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    6;

  void Swap(OrNode* other);
  friend void swap(OrNode& a, OrNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline OrNode* New() const final {
    return CreateMaybeMessage<OrNode>(nullptr);
  }

  OrNode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<OrNode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const OrNode& from);
  void MergeFrom(const OrNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(OrNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .types.TreeNode args = 1;
  int args_size() const;
  void clear_args();
  static const int kArgsFieldNumber = 1;
  ::types::TreeNode* mutable_args(int index);
  ::google::protobuf::RepeatedPtrField< ::types::TreeNode >*
      mutable_args();
  const ::types::TreeNode& args(int index) const;
  ::types::TreeNode* add_args();
  const ::google::protobuf::RepeatedPtrField< ::types::TreeNode >&
      args() const;

  // @@protoc_insertion_point(class_scope:types.OrNode)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::types::TreeNode > args_;
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class NullNode :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.NullNode) */ {
 public:
  NullNode();
  virtual ~NullNode();

  NullNode(const NullNode& from);

  inline NullNode& operator=(const NullNode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  NullNode(NullNode&& from) noexcept
    : NullNode() {
    *this = ::std::move(from);
  }

  inline NullNode& operator=(NullNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const NullNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const NullNode* internal_default_instance() {
    return reinterpret_cast<const NullNode*>(
               &_NullNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    7;

  void Swap(NullNode* other);
  friend void swap(NullNode& a, NullNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline NullNode* New() const final {
    return CreateMaybeMessage<NullNode>(nullptr);
  }

  NullNode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<NullNode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const NullNode& from);
  void MergeFrom(const NullNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(NullNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .types.ExtGandivaType type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  const ::types::ExtGandivaType& type() const;
  ::types::ExtGandivaType* release_type();
  ::types::ExtGandivaType* mutable_type();
  void set_allocated_type(::types::ExtGandivaType* type);

  // @@protoc_insertion_point(class_scope:types.NullNode)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::types::ExtGandivaType* type_;
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class IntNode :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.IntNode) */ {
 public:
  IntNode();
  virtual ~IntNode();

  IntNode(const IntNode& from);

  inline IntNode& operator=(const IntNode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IntNode(IntNode&& from) noexcept
    : IntNode() {
    *this = ::std::move(from);
  }

  inline IntNode& operator=(IntNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const IntNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IntNode* internal_default_instance() {
    return reinterpret_cast<const IntNode*>(
               &_IntNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    8;

  void Swap(IntNode* other);
  friend void swap(IntNode& a, IntNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IntNode* New() const final {
    return CreateMaybeMessage<IntNode>(nullptr);
  }

  IntNode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IntNode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IntNode& from);
  void MergeFrom(const IntNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int32 value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::int32 value() const;
  void set_value(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:types.IntNode)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int32 value_;
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class FloatNode :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.FloatNode) */ {
 public:
  FloatNode();
  virtual ~FloatNode();

  FloatNode(const FloatNode& from);

  inline FloatNode& operator=(const FloatNode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FloatNode(FloatNode&& from) noexcept
    : FloatNode() {
    *this = ::std::move(from);
  }

  inline FloatNode& operator=(FloatNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FloatNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FloatNode* internal_default_instance() {
    return reinterpret_cast<const FloatNode*>(
               &_FloatNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    9;

  void Swap(FloatNode* other);
  friend void swap(FloatNode& a, FloatNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FloatNode* New() const final {
    return CreateMaybeMessage<FloatNode>(nullptr);
  }

  FloatNode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FloatNode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FloatNode& from);
  void MergeFrom(const FloatNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FloatNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional float value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  float value() const;
  void set_value(float value);

  // @@protoc_insertion_point(class_scope:types.FloatNode)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  float value_;
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class DoubleNode :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.DoubleNode) */ {
 public:
  DoubleNode();
  virtual ~DoubleNode();

  DoubleNode(const DoubleNode& from);

  inline DoubleNode& operator=(const DoubleNode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DoubleNode(DoubleNode&& from) noexcept
    : DoubleNode() {
    *this = ::std::move(from);
  }

  inline DoubleNode& operator=(DoubleNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DoubleNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DoubleNode* internal_default_instance() {
    return reinterpret_cast<const DoubleNode*>(
               &_DoubleNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    10;

  void Swap(DoubleNode* other);
  friend void swap(DoubleNode& a, DoubleNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DoubleNode* New() const final {
    return CreateMaybeMessage<DoubleNode>(nullptr);
  }

  DoubleNode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DoubleNode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DoubleNode& from);
  void MergeFrom(const DoubleNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DoubleNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional double value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  double value() const;
  void set_value(double value);

  // @@protoc_insertion_point(class_scope:types.DoubleNode)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  double value_;
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class BooleanNode :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.BooleanNode) */ {
 public:
  BooleanNode();
  virtual ~BooleanNode();

  BooleanNode(const BooleanNode& from);

  inline BooleanNode& operator=(const BooleanNode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BooleanNode(BooleanNode&& from) noexcept
    : BooleanNode() {
    *this = ::std::move(from);
  }

  inline BooleanNode& operator=(BooleanNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BooleanNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BooleanNode* internal_default_instance() {
    return reinterpret_cast<const BooleanNode*>(
               &_BooleanNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    11;

  void Swap(BooleanNode* other);
  friend void swap(BooleanNode& a, BooleanNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BooleanNode* New() const final {
    return CreateMaybeMessage<BooleanNode>(nullptr);
  }

  BooleanNode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BooleanNode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BooleanNode& from);
  void MergeFrom(const BooleanNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BooleanNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bool value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  bool value() const;
  void set_value(bool value);

  // @@protoc_insertion_point(class_scope:types.BooleanNode)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  bool value_;
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class LongNode :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.LongNode) */ {
 public:
  LongNode();
  virtual ~LongNode();

  LongNode(const LongNode& from);

  inline LongNode& operator=(const LongNode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LongNode(LongNode&& from) noexcept
    : LongNode() {
    *this = ::std::move(from);
  }

  inline LongNode& operator=(LongNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const LongNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LongNode* internal_default_instance() {
    return reinterpret_cast<const LongNode*>(
               &_LongNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    12;

  void Swap(LongNode* other);
  friend void swap(LongNode& a, LongNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LongNode* New() const final {
    return CreateMaybeMessage<LongNode>(nullptr);
  }

  LongNode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LongNode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LongNode& from);
  void MergeFrom(const LongNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LongNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  ::google::protobuf::int64 value() const;
  void set_value(::google::protobuf::int64 value);

  // @@protoc_insertion_point(class_scope:types.LongNode)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::int64 value_;
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class StringNode :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.StringNode) */ {
 public:
  StringNode();
  virtual ~StringNode();

  StringNode(const StringNode& from);

  inline StringNode& operator=(const StringNode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StringNode(StringNode&& from) noexcept
    : StringNode() {
    *this = ::std::move(from);
  }

  inline StringNode& operator=(StringNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const StringNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StringNode* internal_default_instance() {
    return reinterpret_cast<const StringNode*>(
               &_StringNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    13;

  void Swap(StringNode* other);
  friend void swap(StringNode& a, StringNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StringNode* New() const final {
    return CreateMaybeMessage<StringNode>(nullptr);
  }

  StringNode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StringNode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StringNode& from);
  void MergeFrom(const StringNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:types.StringNode)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class BinaryNode :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.BinaryNode) */ {
 public:
  BinaryNode();
  virtual ~BinaryNode();

  BinaryNode(const BinaryNode& from);

  inline BinaryNode& operator=(const BinaryNode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BinaryNode(BinaryNode&& from) noexcept
    : BinaryNode() {
    *this = ::std::move(from);
  }

  inline BinaryNode& operator=(BinaryNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BinaryNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinaryNode* internal_default_instance() {
    return reinterpret_cast<const BinaryNode*>(
               &_BinaryNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    14;

  void Swap(BinaryNode* other);
  friend void swap(BinaryNode& a, BinaryNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BinaryNode* New() const final {
    return CreateMaybeMessage<BinaryNode>(nullptr);
  }

  BinaryNode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BinaryNode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BinaryNode& from);
  void MergeFrom(const BinaryNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinaryNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional bytes value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const void* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // @@protoc_insertion_point(class_scope:types.BinaryNode)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class DecimalNode :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.DecimalNode) */ {
 public:
  DecimalNode();
  virtual ~DecimalNode();

  DecimalNode(const DecimalNode& from);

  inline DecimalNode& operator=(const DecimalNode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DecimalNode(DecimalNode&& from) noexcept
    : DecimalNode() {
    *this = ::std::move(from);
  }

  inline DecimalNode& operator=(DecimalNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const DecimalNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DecimalNode* internal_default_instance() {
    return reinterpret_cast<const DecimalNode*>(
               &_DecimalNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    15;

  void Swap(DecimalNode* other);
  friend void swap(DecimalNode& a, DecimalNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DecimalNode* New() const final {
    return CreateMaybeMessage<DecimalNode>(nullptr);
  }

  DecimalNode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DecimalNode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DecimalNode& from);
  void MergeFrom(const DecimalNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DecimalNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string value = 1;
  bool has_value() const;
  void clear_value();
  static const int kValueFieldNumber = 1;
  const ::std::string& value() const;
  void set_value(const ::std::string& value);
  #if LANG_CXX11
  void set_value(::std::string&& value);
  #endif
  void set_value(const char* value);
  void set_value(const char* value, size_t size);
  ::std::string* mutable_value();
  ::std::string* release_value();
  void set_allocated_value(::std::string* value);

  // optional int32 precision = 2;
  bool has_precision() const;
  void clear_precision();
  static const int kPrecisionFieldNumber = 2;
  ::google::protobuf::int32 precision() const;
  void set_precision(::google::protobuf::int32 value);

  // optional int32 scale = 3;
  bool has_scale() const;
  void clear_scale();
  static const int kScaleFieldNumber = 3;
  ::google::protobuf::int32 scale() const;
  void set_scale(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:types.DecimalNode)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::internal::ArenaStringPtr value_;
  ::google::protobuf::int32 precision_;
  ::google::protobuf::int32 scale_;
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class TreeNode :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.TreeNode) */ {
 public:
  TreeNode();
  virtual ~TreeNode();

  TreeNode(const TreeNode& from);

  inline TreeNode& operator=(const TreeNode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  TreeNode(TreeNode&& from) noexcept
    : TreeNode() {
    *this = ::std::move(from);
  }

  inline TreeNode& operator=(TreeNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const TreeNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const TreeNode* internal_default_instance() {
    return reinterpret_cast<const TreeNode*>(
               &_TreeNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    16;

  void Swap(TreeNode* other);
  friend void swap(TreeNode& a, TreeNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline TreeNode* New() const final {
    return CreateMaybeMessage<TreeNode>(nullptr);
  }

  TreeNode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<TreeNode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const TreeNode& from);
  void MergeFrom(const TreeNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(TreeNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .types.FieldNode fieldNode = 1;
  bool has_fieldnode() const;
  void clear_fieldnode();
  static const int kFieldNodeFieldNumber = 1;
  const ::types::FieldNode& fieldnode() const;
  ::types::FieldNode* release_fieldnode();
  ::types::FieldNode* mutable_fieldnode();
  void set_allocated_fieldnode(::types::FieldNode* fieldnode);

  // optional .types.FunctionNode fnNode = 2;
  bool has_fnnode() const;
  void clear_fnnode();
  static const int kFnNodeFieldNumber = 2;
  const ::types::FunctionNode& fnnode() const;
  ::types::FunctionNode* release_fnnode();
  ::types::FunctionNode* mutable_fnnode();
  void set_allocated_fnnode(::types::FunctionNode* fnnode);

  // optional .types.IfNode ifNode = 6;
  bool has_ifnode() const;
  void clear_ifnode();
  static const int kIfNodeFieldNumber = 6;
  const ::types::IfNode& ifnode() const;
  ::types::IfNode* release_ifnode();
  ::types::IfNode* mutable_ifnode();
  void set_allocated_ifnode(::types::IfNode* ifnode);

  // optional .types.AndNode andNode = 7;
  bool has_andnode() const;
  void clear_andnode();
  static const int kAndNodeFieldNumber = 7;
  const ::types::AndNode& andnode() const;
  ::types::AndNode* release_andnode();
  ::types::AndNode* mutable_andnode();
  void set_allocated_andnode(::types::AndNode* andnode);

  // optional .types.OrNode orNode = 8;
  bool has_ornode() const;
  void clear_ornode();
  static const int kOrNodeFieldNumber = 8;
  const ::types::OrNode& ornode() const;
  ::types::OrNode* release_ornode();
  ::types::OrNode* mutable_ornode();
  void set_allocated_ornode(::types::OrNode* ornode);

  // optional .types.NullNode nullNode = 11;
  bool has_nullnode() const;
  void clear_nullnode();
  static const int kNullNodeFieldNumber = 11;
  const ::types::NullNode& nullnode() const;
  ::types::NullNode* release_nullnode();
  ::types::NullNode* mutable_nullnode();
  void set_allocated_nullnode(::types::NullNode* nullnode);

  // optional .types.IntNode intNode = 12;
  bool has_intnode() const;
  void clear_intnode();
  static const int kIntNodeFieldNumber = 12;
  const ::types::IntNode& intnode() const;
  ::types::IntNode* release_intnode();
  ::types::IntNode* mutable_intnode();
  void set_allocated_intnode(::types::IntNode* intnode);

  // optional .types.FloatNode floatNode = 13;
  bool has_floatnode() const;
  void clear_floatnode();
  static const int kFloatNodeFieldNumber = 13;
  const ::types::FloatNode& floatnode() const;
  ::types::FloatNode* release_floatnode();
  ::types::FloatNode* mutable_floatnode();
  void set_allocated_floatnode(::types::FloatNode* floatnode);

  // optional .types.LongNode longNode = 14;
  bool has_longnode() const;
  void clear_longnode();
  static const int kLongNodeFieldNumber = 14;
  const ::types::LongNode& longnode() const;
  ::types::LongNode* release_longnode();
  ::types::LongNode* mutable_longnode();
  void set_allocated_longnode(::types::LongNode* longnode);

  // optional .types.BooleanNode booleanNode = 15;
  bool has_booleannode() const;
  void clear_booleannode();
  static const int kBooleanNodeFieldNumber = 15;
  const ::types::BooleanNode& booleannode() const;
  ::types::BooleanNode* release_booleannode();
  ::types::BooleanNode* mutable_booleannode();
  void set_allocated_booleannode(::types::BooleanNode* booleannode);

  // optional .types.DoubleNode doubleNode = 16;
  bool has_doublenode() const;
  void clear_doublenode();
  static const int kDoubleNodeFieldNumber = 16;
  const ::types::DoubleNode& doublenode() const;
  ::types::DoubleNode* release_doublenode();
  ::types::DoubleNode* mutable_doublenode();
  void set_allocated_doublenode(::types::DoubleNode* doublenode);

  // optional .types.StringNode stringNode = 17;
  bool has_stringnode() const;
  void clear_stringnode();
  static const int kStringNodeFieldNumber = 17;
  const ::types::StringNode& stringnode() const;
  ::types::StringNode* release_stringnode();
  ::types::StringNode* mutable_stringnode();
  void set_allocated_stringnode(::types::StringNode* stringnode);

  // optional .types.BinaryNode binaryNode = 18;
  bool has_binarynode() const;
  void clear_binarynode();
  static const int kBinaryNodeFieldNumber = 18;
  const ::types::BinaryNode& binarynode() const;
  ::types::BinaryNode* release_binarynode();
  ::types::BinaryNode* mutable_binarynode();
  void set_allocated_binarynode(::types::BinaryNode* binarynode);

  // optional .types.DecimalNode decimalNode = 19;
  bool has_decimalnode() const;
  void clear_decimalnode();
  static const int kDecimalNodeFieldNumber = 19;
  const ::types::DecimalNode& decimalnode() const;
  ::types::DecimalNode* release_decimalnode();
  ::types::DecimalNode* mutable_decimalnode();
  void set_allocated_decimalnode(::types::DecimalNode* decimalnode);

  // optional .types.InNode inNode = 21;
  bool has_innode() const;
  void clear_innode();
  static const int kInNodeFieldNumber = 21;
  const ::types::InNode& innode() const;
  ::types::InNode* release_innode();
  ::types::InNode* mutable_innode();
  void set_allocated_innode(::types::InNode* innode);

  // @@protoc_insertion_point(class_scope:types.TreeNode)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::types::FieldNode* fieldnode_;
  ::types::FunctionNode* fnnode_;
  ::types::IfNode* ifnode_;
  ::types::AndNode* andnode_;
  ::types::OrNode* ornode_;
  ::types::NullNode* nullnode_;
  ::types::IntNode* intnode_;
  ::types::FloatNode* floatnode_;
  ::types::LongNode* longnode_;
  ::types::BooleanNode* booleannode_;
  ::types::DoubleNode* doublenode_;
  ::types::StringNode* stringnode_;
  ::types::BinaryNode* binarynode_;
  ::types::DecimalNode* decimalnode_;
  ::types::InNode* innode_;
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class ExpressionRoot :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.ExpressionRoot) */ {
 public:
  ExpressionRoot();
  virtual ~ExpressionRoot();

  ExpressionRoot(const ExpressionRoot& from);

  inline ExpressionRoot& operator=(const ExpressionRoot& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExpressionRoot(ExpressionRoot&& from) noexcept
    : ExpressionRoot() {
    *this = ::std::move(from);
  }

  inline ExpressionRoot& operator=(ExpressionRoot&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ExpressionRoot& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExpressionRoot* internal_default_instance() {
    return reinterpret_cast<const ExpressionRoot*>(
               &_ExpressionRoot_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    17;

  void Swap(ExpressionRoot* other);
  friend void swap(ExpressionRoot& a, ExpressionRoot& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExpressionRoot* New() const final {
    return CreateMaybeMessage<ExpressionRoot>(nullptr);
  }

  ExpressionRoot* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExpressionRoot>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExpressionRoot& from);
  void MergeFrom(const ExpressionRoot& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExpressionRoot* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .types.TreeNode root = 1;
  bool has_root() const;
  void clear_root();
  static const int kRootFieldNumber = 1;
  const ::types::TreeNode& root() const;
  ::types::TreeNode* release_root();
  ::types::TreeNode* mutable_root();
  void set_allocated_root(::types::TreeNode* root);

  // optional .types.Field resultType = 2;
  bool has_resulttype() const;
  void clear_resulttype();
  static const int kResultTypeFieldNumber = 2;
  const ::types::Field& resulttype() const;
  ::types::Field* release_resulttype();
  ::types::Field* mutable_resulttype();
  void set_allocated_resulttype(::types::Field* resulttype);

  // @@protoc_insertion_point(class_scope:types.ExpressionRoot)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::types::TreeNode* root_;
  ::types::Field* resulttype_;
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class ExpressionList :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.ExpressionList) */ {
 public:
  ExpressionList();
  virtual ~ExpressionList();

  ExpressionList(const ExpressionList& from);

  inline ExpressionList& operator=(const ExpressionList& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  ExpressionList(ExpressionList&& from) noexcept
    : ExpressionList() {
    *this = ::std::move(from);
  }

  inline ExpressionList& operator=(ExpressionList&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const ExpressionList& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const ExpressionList* internal_default_instance() {
    return reinterpret_cast<const ExpressionList*>(
               &_ExpressionList_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    18;

  void Swap(ExpressionList* other);
  friend void swap(ExpressionList& a, ExpressionList& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline ExpressionList* New() const final {
    return CreateMaybeMessage<ExpressionList>(nullptr);
  }

  ExpressionList* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<ExpressionList>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const ExpressionList& from);
  void MergeFrom(const ExpressionList& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(ExpressionList* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .types.ExpressionRoot exprs = 2;
  int exprs_size() const;
  void clear_exprs();
  static const int kExprsFieldNumber = 2;
  ::types::ExpressionRoot* mutable_exprs(int index);
  ::google::protobuf::RepeatedPtrField< ::types::ExpressionRoot >*
      mutable_exprs();
  const ::types::ExpressionRoot& exprs(int index) const;
  ::types::ExpressionRoot* add_exprs();
  const ::google::protobuf::RepeatedPtrField< ::types::ExpressionRoot >&
      exprs() const;

  // @@protoc_insertion_point(class_scope:types.ExpressionList)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::types::ExpressionRoot > exprs_;
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class Condition :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.Condition) */ {
 public:
  Condition();
  virtual ~Condition();

  Condition(const Condition& from);

  inline Condition& operator=(const Condition& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Condition(Condition&& from) noexcept
    : Condition() {
    *this = ::std::move(from);
  }

  inline Condition& operator=(Condition&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Condition& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Condition* internal_default_instance() {
    return reinterpret_cast<const Condition*>(
               &_Condition_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    19;

  void Swap(Condition* other);
  friend void swap(Condition& a, Condition& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Condition* New() const final {
    return CreateMaybeMessage<Condition>(nullptr);
  }

  Condition* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Condition>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Condition& from);
  void MergeFrom(const Condition& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Condition* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .types.TreeNode root = 1;
  bool has_root() const;
  void clear_root();
  static const int kRootFieldNumber = 1;
  const ::types::TreeNode& root() const;
  ::types::TreeNode* release_root();
  ::types::TreeNode* mutable_root();
  void set_allocated_root(::types::TreeNode* root);

  // @@protoc_insertion_point(class_scope:types.Condition)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::types::TreeNode* root_;
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class Schema :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.Schema) */ {
 public:
  Schema();
  virtual ~Schema();

  Schema(const Schema& from);

  inline Schema& operator=(const Schema& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Schema(Schema&& from) noexcept
    : Schema() {
    *this = ::std::move(from);
  }

  inline Schema& operator=(Schema&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const Schema& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Schema* internal_default_instance() {
    return reinterpret_cast<const Schema*>(
               &_Schema_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    20;

  void Swap(Schema* other);
  friend void swap(Schema& a, Schema& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Schema* New() const final {
    return CreateMaybeMessage<Schema>(nullptr);
  }

  Schema* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Schema>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Schema& from);
  void MergeFrom(const Schema& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Schema* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .types.Field columns = 1;
  int columns_size() const;
  void clear_columns();
  static const int kColumnsFieldNumber = 1;
  ::types::Field* mutable_columns(int index);
  ::google::protobuf::RepeatedPtrField< ::types::Field >*
      mutable_columns();
  const ::types::Field& columns(int index) const;
  ::types::Field* add_columns();
  const ::google::protobuf::RepeatedPtrField< ::types::Field >&
      columns() const;

  // @@protoc_insertion_point(class_scope:types.Schema)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::types::Field > columns_;
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class GandivaDataTypes :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.GandivaDataTypes) */ {
 public:
  GandivaDataTypes();
  virtual ~GandivaDataTypes();

  GandivaDataTypes(const GandivaDataTypes& from);

  inline GandivaDataTypes& operator=(const GandivaDataTypes& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GandivaDataTypes(GandivaDataTypes&& from) noexcept
    : GandivaDataTypes() {
    *this = ::std::move(from);
  }

  inline GandivaDataTypes& operator=(GandivaDataTypes&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GandivaDataTypes& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GandivaDataTypes* internal_default_instance() {
    return reinterpret_cast<const GandivaDataTypes*>(
               &_GandivaDataTypes_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    21;

  void Swap(GandivaDataTypes* other);
  friend void swap(GandivaDataTypes& a, GandivaDataTypes& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GandivaDataTypes* New() const final {
    return CreateMaybeMessage<GandivaDataTypes>(nullptr);
  }

  GandivaDataTypes* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GandivaDataTypes>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GandivaDataTypes& from);
  void MergeFrom(const GandivaDataTypes& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GandivaDataTypes* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .types.ExtGandivaType dataType = 1;
  int datatype_size() const;
  void clear_datatype();
  static const int kDataTypeFieldNumber = 1;
  ::types::ExtGandivaType* mutable_datatype(int index);
  ::google::protobuf::RepeatedPtrField< ::types::ExtGandivaType >*
      mutable_datatype();
  const ::types::ExtGandivaType& datatype(int index) const;
  ::types::ExtGandivaType* add_datatype();
  const ::google::protobuf::RepeatedPtrField< ::types::ExtGandivaType >&
      datatype() const;

  // @@protoc_insertion_point(class_scope:types.GandivaDataTypes)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::types::ExtGandivaType > datatype_;
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class GandivaFunctions :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.GandivaFunctions) */ {
 public:
  GandivaFunctions();
  virtual ~GandivaFunctions();

  GandivaFunctions(const GandivaFunctions& from);

  inline GandivaFunctions& operator=(const GandivaFunctions& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  GandivaFunctions(GandivaFunctions&& from) noexcept
    : GandivaFunctions() {
    *this = ::std::move(from);
  }

  inline GandivaFunctions& operator=(GandivaFunctions&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const GandivaFunctions& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const GandivaFunctions* internal_default_instance() {
    return reinterpret_cast<const GandivaFunctions*>(
               &_GandivaFunctions_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    22;

  void Swap(GandivaFunctions* other);
  friend void swap(GandivaFunctions& a, GandivaFunctions& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline GandivaFunctions* New() const final {
    return CreateMaybeMessage<GandivaFunctions>(nullptr);
  }

  GandivaFunctions* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<GandivaFunctions>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const GandivaFunctions& from);
  void MergeFrom(const GandivaFunctions& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(GandivaFunctions* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .types.FunctionSignature function = 1;
  int function_size() const;
  void clear_function();
  static const int kFunctionFieldNumber = 1;
  ::types::FunctionSignature* mutable_function(int index);
  ::google::protobuf::RepeatedPtrField< ::types::FunctionSignature >*
      mutable_function();
  const ::types::FunctionSignature& function(int index) const;
  ::types::FunctionSignature* add_function();
  const ::google::protobuf::RepeatedPtrField< ::types::FunctionSignature >&
      function() const;

  // @@protoc_insertion_point(class_scope:types.GandivaFunctions)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::types::FunctionSignature > function_;
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class FunctionSignature :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.FunctionSignature) */ {
 public:
  FunctionSignature();
  virtual ~FunctionSignature();

  FunctionSignature(const FunctionSignature& from);

  inline FunctionSignature& operator=(const FunctionSignature& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  FunctionSignature(FunctionSignature&& from) noexcept
    : FunctionSignature() {
    *this = ::std::move(from);
  }

  inline FunctionSignature& operator=(FunctionSignature&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const FunctionSignature& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const FunctionSignature* internal_default_instance() {
    return reinterpret_cast<const FunctionSignature*>(
               &_FunctionSignature_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    23;

  void Swap(FunctionSignature* other);
  friend void swap(FunctionSignature& a, FunctionSignature& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline FunctionSignature* New() const final {
    return CreateMaybeMessage<FunctionSignature>(nullptr);
  }

  FunctionSignature* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<FunctionSignature>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const FunctionSignature& from);
  void MergeFrom(const FunctionSignature& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(FunctionSignature* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .types.ExtGandivaType paramTypes = 3;
  int paramtypes_size() const;
  void clear_paramtypes();
  static const int kParamTypesFieldNumber = 3;
  ::types::ExtGandivaType* mutable_paramtypes(int index);
  ::google::protobuf::RepeatedPtrField< ::types::ExtGandivaType >*
      mutable_paramtypes();
  const ::types::ExtGandivaType& paramtypes(int index) const;
  ::types::ExtGandivaType* add_paramtypes();
  const ::google::protobuf::RepeatedPtrField< ::types::ExtGandivaType >&
      paramtypes() const;

  // optional string name = 1;
  bool has_name() const;
  void clear_name();
  static const int kNameFieldNumber = 1;
  const ::std::string& name() const;
  void set_name(const ::std::string& value);
  #if LANG_CXX11
  void set_name(::std::string&& value);
  #endif
  void set_name(const char* value);
  void set_name(const char* value, size_t size);
  ::std::string* mutable_name();
  ::std::string* release_name();
  void set_allocated_name(::std::string* name);

  // optional .types.ExtGandivaType returnType = 2;
  bool has_returntype() const;
  void clear_returntype();
  static const int kReturnTypeFieldNumber = 2;
  const ::types::ExtGandivaType& returntype() const;
  ::types::ExtGandivaType* release_returntype();
  ::types::ExtGandivaType* mutable_returntype();
  void set_allocated_returntype(::types::ExtGandivaType* returntype);

  // @@protoc_insertion_point(class_scope:types.FunctionSignature)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::types::ExtGandivaType > paramtypes_;
  ::google::protobuf::internal::ArenaStringPtr name_;
  ::types::ExtGandivaType* returntype_;
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class InNode :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.InNode) */ {
 public:
  InNode();
  virtual ~InNode();

  InNode(const InNode& from);

  inline InNode& operator=(const InNode& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  InNode(InNode&& from) noexcept
    : InNode() {
    *this = ::std::move(from);
  }

  inline InNode& operator=(InNode&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const InNode& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const InNode* internal_default_instance() {
    return reinterpret_cast<const InNode*>(
               &_InNode_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    24;

  void Swap(InNode* other);
  friend void swap(InNode& a, InNode& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline InNode* New() const final {
    return CreateMaybeMessage<InNode>(nullptr);
  }

  InNode* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<InNode>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const InNode& from);
  void MergeFrom(const InNode& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(InNode* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .types.FieldNode field = 1;
  bool has_field() const;
  void clear_field();
  static const int kFieldFieldNumber = 1;
  const ::types::FieldNode& field() const;
  ::types::FieldNode* release_field();
  ::types::FieldNode* mutable_field();
  void set_allocated_field(::types::FieldNode* field);

  // optional .types.IntConstants intValues = 2;
  bool has_intvalues() const;
  void clear_intvalues();
  static const int kIntValuesFieldNumber = 2;
  const ::types::IntConstants& intvalues() const;
  ::types::IntConstants* release_intvalues();
  ::types::IntConstants* mutable_intvalues();
  void set_allocated_intvalues(::types::IntConstants* intvalues);

  // optional .types.LongConstants longValues = 3;
  bool has_longvalues() const;
  void clear_longvalues();
  static const int kLongValuesFieldNumber = 3;
  const ::types::LongConstants& longvalues() const;
  ::types::LongConstants* release_longvalues();
  ::types::LongConstants* mutable_longvalues();
  void set_allocated_longvalues(::types::LongConstants* longvalues);

  // optional .types.StringConstants stringValues = 4;
  bool has_stringvalues() const;
  void clear_stringvalues();
  static const int kStringValuesFieldNumber = 4;
  const ::types::StringConstants& stringvalues() const;
  ::types::StringConstants* release_stringvalues();
  ::types::StringConstants* mutable_stringvalues();
  void set_allocated_stringvalues(::types::StringConstants* stringvalues);

  // optional .types.BinaryConstants binaryValues = 5;
  bool has_binaryvalues() const;
  void clear_binaryvalues();
  static const int kBinaryValuesFieldNumber = 5;
  const ::types::BinaryConstants& binaryvalues() const;
  ::types::BinaryConstants* release_binaryvalues();
  ::types::BinaryConstants* mutable_binaryvalues();
  void set_allocated_binaryvalues(::types::BinaryConstants* binaryvalues);

  // @@protoc_insertion_point(class_scope:types.InNode)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::types::FieldNode* field_;
  ::types::IntConstants* intvalues_;
  ::types::LongConstants* longvalues_;
  ::types::StringConstants* stringvalues_;
  ::types::BinaryConstants* binaryvalues_;
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class IntConstants :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.IntConstants) */ {
 public:
  IntConstants();
  virtual ~IntConstants();

  IntConstants(const IntConstants& from);

  inline IntConstants& operator=(const IntConstants& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  IntConstants(IntConstants&& from) noexcept
    : IntConstants() {
    *this = ::std::move(from);
  }

  inline IntConstants& operator=(IntConstants&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const IntConstants& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const IntConstants* internal_default_instance() {
    return reinterpret_cast<const IntConstants*>(
               &_IntConstants_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    25;

  void Swap(IntConstants* other);
  friend void swap(IntConstants& a, IntConstants& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline IntConstants* New() const final {
    return CreateMaybeMessage<IntConstants>(nullptr);
  }

  IntConstants* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<IntConstants>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const IntConstants& from);
  void MergeFrom(const IntConstants& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(IntConstants* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .types.IntNode intValues = 1;
  int intvalues_size() const;
  void clear_intvalues();
  static const int kIntValuesFieldNumber = 1;
  ::types::IntNode* mutable_intvalues(int index);
  ::google::protobuf::RepeatedPtrField< ::types::IntNode >*
      mutable_intvalues();
  const ::types::IntNode& intvalues(int index) const;
  ::types::IntNode* add_intvalues();
  const ::google::protobuf::RepeatedPtrField< ::types::IntNode >&
      intvalues() const;

  // @@protoc_insertion_point(class_scope:types.IntConstants)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::types::IntNode > intvalues_;
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class LongConstants :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.LongConstants) */ {
 public:
  LongConstants();
  virtual ~LongConstants();

  LongConstants(const LongConstants& from);

  inline LongConstants& operator=(const LongConstants& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  LongConstants(LongConstants&& from) noexcept
    : LongConstants() {
    *this = ::std::move(from);
  }

  inline LongConstants& operator=(LongConstants&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const LongConstants& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const LongConstants* internal_default_instance() {
    return reinterpret_cast<const LongConstants*>(
               &_LongConstants_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    26;

  void Swap(LongConstants* other);
  friend void swap(LongConstants& a, LongConstants& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline LongConstants* New() const final {
    return CreateMaybeMessage<LongConstants>(nullptr);
  }

  LongConstants* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<LongConstants>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const LongConstants& from);
  void MergeFrom(const LongConstants& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(LongConstants* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .types.LongNode longValues = 1;
  int longvalues_size() const;
  void clear_longvalues();
  static const int kLongValuesFieldNumber = 1;
  ::types::LongNode* mutable_longvalues(int index);
  ::google::protobuf::RepeatedPtrField< ::types::LongNode >*
      mutable_longvalues();
  const ::types::LongNode& longvalues(int index) const;
  ::types::LongNode* add_longvalues();
  const ::google::protobuf::RepeatedPtrField< ::types::LongNode >&
      longvalues() const;

  // @@protoc_insertion_point(class_scope:types.LongConstants)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::types::LongNode > longvalues_;
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class StringConstants :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.StringConstants) */ {
 public:
  StringConstants();
  virtual ~StringConstants();

  StringConstants(const StringConstants& from);

  inline StringConstants& operator=(const StringConstants& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  StringConstants(StringConstants&& from) noexcept
    : StringConstants() {
    *this = ::std::move(from);
  }

  inline StringConstants& operator=(StringConstants&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const StringConstants& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const StringConstants* internal_default_instance() {
    return reinterpret_cast<const StringConstants*>(
               &_StringConstants_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    27;

  void Swap(StringConstants* other);
  friend void swap(StringConstants& a, StringConstants& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline StringConstants* New() const final {
    return CreateMaybeMessage<StringConstants>(nullptr);
  }

  StringConstants* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<StringConstants>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const StringConstants& from);
  void MergeFrom(const StringConstants& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(StringConstants* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .types.StringNode stringValues = 1;
  int stringvalues_size() const;
  void clear_stringvalues();
  static const int kStringValuesFieldNumber = 1;
  ::types::StringNode* mutable_stringvalues(int index);
  ::google::protobuf::RepeatedPtrField< ::types::StringNode >*
      mutable_stringvalues();
  const ::types::StringNode& stringvalues(int index) const;
  ::types::StringNode* add_stringvalues();
  const ::google::protobuf::RepeatedPtrField< ::types::StringNode >&
      stringvalues() const;

  // @@protoc_insertion_point(class_scope:types.StringConstants)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::types::StringNode > stringvalues_;
  friend struct ::TableStruct_Types_2eproto;
};
// -------------------------------------------------------------------

class BinaryConstants :
    public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:types.BinaryConstants) */ {
 public:
  BinaryConstants();
  virtual ~BinaryConstants();

  BinaryConstants(const BinaryConstants& from);

  inline BinaryConstants& operator=(const BinaryConstants& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  BinaryConstants(BinaryConstants&& from) noexcept
    : BinaryConstants() {
    *this = ::std::move(from);
  }

  inline BinaryConstants& operator=(BinaryConstants&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor() {
    return default_instance().GetDescriptor();
  }
  static const BinaryConstants& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const BinaryConstants* internal_default_instance() {
    return reinterpret_cast<const BinaryConstants*>(
               &_BinaryConstants_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    28;

  void Swap(BinaryConstants* other);
  friend void swap(BinaryConstants& a, BinaryConstants& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline BinaryConstants* New() const final {
    return CreateMaybeMessage<BinaryConstants>(nullptr);
  }

  BinaryConstants* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<BinaryConstants>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const BinaryConstants& from);
  void MergeFrom(const BinaryConstants& from);
  PROTOBUF_ATTRIBUTE_REINITIALIZES void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  #if GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  static const char* _InternalParse(const char* begin, const char* end, void* object, ::google::protobuf::internal::ParseContext* ctx);
  ::google::protobuf::internal::ParseFunc _ParseFunc() const final { return _InternalParse; }
  #else
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  #endif  // GOOGLE_PROTOBUF_ENABLE_EXPERIMENTAL_PARSER
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(BinaryConstants* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return nullptr;
  }
  inline void* MaybeArenaPtr() const {
    return nullptr;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .types.BinaryNode binaryValues = 1;
  int binaryvalues_size() const;
  void clear_binaryvalues();
  static const int kBinaryValuesFieldNumber = 1;
  ::types::BinaryNode* mutable_binaryvalues(int index);
  ::google::protobuf::RepeatedPtrField< ::types::BinaryNode >*
      mutable_binaryvalues();
  const ::types::BinaryNode& binaryvalues(int index) const;
  ::types::BinaryNode* add_binaryvalues();
  const ::google::protobuf::RepeatedPtrField< ::types::BinaryNode >&
      binaryvalues() const;

  // @@protoc_insertion_point(class_scope:types.BinaryConstants)
 private:
  class HasBitSetters;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::types::BinaryNode > binaryvalues_;
  friend struct ::TableStruct_Types_2eproto;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// ExtGandivaType

// optional .types.GandivaType type = 1;
inline bool ExtGandivaType::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExtGandivaType::clear_type() {
  type_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::types::GandivaType ExtGandivaType::type() const {
  // @@protoc_insertion_point(field_get:types.ExtGandivaType.type)
  return static_cast< ::types::GandivaType >(type_);
}
inline void ExtGandivaType::set_type(::types::GandivaType value) {
  assert(::types::GandivaType_IsValid(value));
  _has_bits_[0] |= 0x00000002u;
  type_ = value;
  // @@protoc_insertion_point(field_set:types.ExtGandivaType.type)
}

// optional uint32 width = 2;
inline bool ExtGandivaType::has_width() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void ExtGandivaType::clear_width() {
  width_ = 0u;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::uint32 ExtGandivaType::width() const {
  // @@protoc_insertion_point(field_get:types.ExtGandivaType.width)
  return width_;
}
inline void ExtGandivaType::set_width(::google::protobuf::uint32 value) {
  _has_bits_[0] |= 0x00000004u;
  width_ = value;
  // @@protoc_insertion_point(field_set:types.ExtGandivaType.width)
}

// optional int32 precision = 3;
inline bool ExtGandivaType::has_precision() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void ExtGandivaType::clear_precision() {
  precision_ = 0;
  _has_bits_[0] &= ~0x00000008u;
}
inline ::google::protobuf::int32 ExtGandivaType::precision() const {
  // @@protoc_insertion_point(field_get:types.ExtGandivaType.precision)
  return precision_;
}
inline void ExtGandivaType::set_precision(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000008u;
  precision_ = value;
  // @@protoc_insertion_point(field_set:types.ExtGandivaType.precision)
}

// optional int32 scale = 4;
inline bool ExtGandivaType::has_scale() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void ExtGandivaType::clear_scale() {
  scale_ = 0;
  _has_bits_[0] &= ~0x00000010u;
}
inline ::google::protobuf::int32 ExtGandivaType::scale() const {
  // @@protoc_insertion_point(field_get:types.ExtGandivaType.scale)
  return scale_;
}
inline void ExtGandivaType::set_scale(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000010u;
  scale_ = value;
  // @@protoc_insertion_point(field_set:types.ExtGandivaType.scale)
}

// optional .types.DateUnit dateUnit = 5;
inline bool ExtGandivaType::has_dateunit() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void ExtGandivaType::clear_dateunit() {
  dateunit_ = 0;
  _has_bits_[0] &= ~0x00000020u;
}
inline ::types::DateUnit ExtGandivaType::dateunit() const {
  // @@protoc_insertion_point(field_get:types.ExtGandivaType.dateUnit)
  return static_cast< ::types::DateUnit >(dateunit_);
}
inline void ExtGandivaType::set_dateunit(::types::DateUnit value) {
  assert(::types::DateUnit_IsValid(value));
  _has_bits_[0] |= 0x00000020u;
  dateunit_ = value;
  // @@protoc_insertion_point(field_set:types.ExtGandivaType.dateUnit)
}

// optional .types.TimeUnit timeUnit = 6;
inline bool ExtGandivaType::has_timeunit() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void ExtGandivaType::clear_timeunit() {
  timeunit_ = 0;
  _has_bits_[0] &= ~0x00000040u;
}
inline ::types::TimeUnit ExtGandivaType::timeunit() const {
  // @@protoc_insertion_point(field_get:types.ExtGandivaType.timeUnit)
  return static_cast< ::types::TimeUnit >(timeunit_);
}
inline void ExtGandivaType::set_timeunit(::types::TimeUnit value) {
  assert(::types::TimeUnit_IsValid(value));
  _has_bits_[0] |= 0x00000040u;
  timeunit_ = value;
  // @@protoc_insertion_point(field_set:types.ExtGandivaType.timeUnit)
}

// optional string timeZone = 7;
inline bool ExtGandivaType::has_timezone() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExtGandivaType::clear_timezone() {
  timezone_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& ExtGandivaType::timezone() const {
  // @@protoc_insertion_point(field_get:types.ExtGandivaType.timeZone)
  return timezone_.GetNoArena();
}
inline void ExtGandivaType::set_timezone(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  timezone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.ExtGandivaType.timeZone)
}
#if LANG_CXX11
inline void ExtGandivaType::set_timezone(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  timezone_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.ExtGandivaType.timeZone)
}
#endif
inline void ExtGandivaType::set_timezone(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  timezone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.ExtGandivaType.timeZone)
}
inline void ExtGandivaType::set_timezone(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  timezone_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.ExtGandivaType.timeZone)
}
inline ::std::string* ExtGandivaType::mutable_timezone() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:types.ExtGandivaType.timeZone)
  return timezone_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* ExtGandivaType::release_timezone() {
  // @@protoc_insertion_point(field_release:types.ExtGandivaType.timeZone)
  if (!has_timezone()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return timezone_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void ExtGandivaType::set_allocated_timezone(::std::string* timezone) {
  if (timezone != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  timezone_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), timezone);
  // @@protoc_insertion_point(field_set_allocated:types.ExtGandivaType.timeZone)
}

// -------------------------------------------------------------------

// Field

// optional string name = 1;
inline bool Field::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Field::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& Field::name() const {
  // @@protoc_insertion_point(field_get:types.Field.name)
  return name_.GetNoArena();
}
inline void Field::set_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.Field.name)
}
#if LANG_CXX11
inline void Field::set_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.Field.name)
}
#endif
inline void Field::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.Field.name)
}
inline void Field::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.Field.name)
}
inline ::std::string* Field::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:types.Field.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Field::release_name() {
  // @@protoc_insertion_point(field_release:types.Field.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Field::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:types.Field.name)
}

// optional .types.ExtGandivaType type = 2;
inline bool Field::has_type() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Field::clear_type() {
  if (type_ != nullptr) type_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::types::ExtGandivaType& Field::type() const {
  const ::types::ExtGandivaType* p = type_;
  // @@protoc_insertion_point(field_get:types.Field.type)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::ExtGandivaType*>(
      &::types::_ExtGandivaType_default_instance_);
}
inline ::types::ExtGandivaType* Field::release_type() {
  // @@protoc_insertion_point(field_release:types.Field.type)
  _has_bits_[0] &= ~0x00000002u;
  ::types::ExtGandivaType* temp = type_;
  type_ = nullptr;
  return temp;
}
inline ::types::ExtGandivaType* Field::mutable_type() {
  _has_bits_[0] |= 0x00000002u;
  if (type_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::ExtGandivaType>(GetArenaNoVirtual());
    type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.Field.type)
  return type_;
}
inline void Field::set_allocated_type(::types::ExtGandivaType* type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete type_;
  }
  if (type) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:types.Field.type)
}

// optional bool nullable = 3;
inline bool Field::has_nullable() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Field::clear_nullable() {
  nullable_ = false;
  _has_bits_[0] &= ~0x00000004u;
}
inline bool Field::nullable() const {
  // @@protoc_insertion_point(field_get:types.Field.nullable)
  return nullable_;
}
inline void Field::set_nullable(bool value) {
  _has_bits_[0] |= 0x00000004u;
  nullable_ = value;
  // @@protoc_insertion_point(field_set:types.Field.nullable)
}

// repeated .types.Field children = 4;
inline int Field::children_size() const {
  return children_.size();
}
inline void Field::clear_children() {
  children_.Clear();
}
inline ::types::Field* Field::mutable_children(int index) {
  // @@protoc_insertion_point(field_mutable:types.Field.children)
  return children_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::types::Field >*
Field::mutable_children() {
  // @@protoc_insertion_point(field_mutable_list:types.Field.children)
  return &children_;
}
inline const ::types::Field& Field::children(int index) const {
  // @@protoc_insertion_point(field_get:types.Field.children)
  return children_.Get(index);
}
inline ::types::Field* Field::add_children() {
  // @@protoc_insertion_point(field_add:types.Field.children)
  return children_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::types::Field >&
Field::children() const {
  // @@protoc_insertion_point(field_list:types.Field.children)
  return children_;
}

// -------------------------------------------------------------------

// FieldNode

// optional .types.Field field = 1;
inline bool FieldNode::has_field() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FieldNode::clear_field() {
  if (field_ != nullptr) field_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::types::Field& FieldNode::field() const {
  const ::types::Field* p = field_;
  // @@protoc_insertion_point(field_get:types.FieldNode.field)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::Field*>(
      &::types::_Field_default_instance_);
}
inline ::types::Field* FieldNode::release_field() {
  // @@protoc_insertion_point(field_release:types.FieldNode.field)
  _has_bits_[0] &= ~0x00000001u;
  ::types::Field* temp = field_;
  field_ = nullptr;
  return temp;
}
inline ::types::Field* FieldNode::mutable_field() {
  _has_bits_[0] |= 0x00000001u;
  if (field_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::Field>(GetArenaNoVirtual());
    field_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.FieldNode.field)
  return field_;
}
inline void FieldNode::set_allocated_field(::types::Field* field) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete field_;
  }
  if (field) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      field = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, field, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  field_ = field;
  // @@protoc_insertion_point(field_set_allocated:types.FieldNode.field)
}

// -------------------------------------------------------------------

// FunctionNode

// optional string functionName = 1;
inline bool FunctionNode::has_functionname() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FunctionNode::clear_functionname() {
  functionname_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& FunctionNode::functionname() const {
  // @@protoc_insertion_point(field_get:types.FunctionNode.functionName)
  return functionname_.GetNoArena();
}
inline void FunctionNode::set_functionname(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  functionname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.FunctionNode.functionName)
}
#if LANG_CXX11
inline void FunctionNode::set_functionname(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  functionname_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.FunctionNode.functionName)
}
#endif
inline void FunctionNode::set_functionname(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  functionname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.FunctionNode.functionName)
}
inline void FunctionNode::set_functionname(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  functionname_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.FunctionNode.functionName)
}
inline ::std::string* FunctionNode::mutable_functionname() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:types.FunctionNode.functionName)
  return functionname_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FunctionNode::release_functionname() {
  // @@protoc_insertion_point(field_release:types.FunctionNode.functionName)
  if (!has_functionname()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return functionname_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FunctionNode::set_allocated_functionname(::std::string* functionname) {
  if (functionname != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  functionname_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), functionname);
  // @@protoc_insertion_point(field_set_allocated:types.FunctionNode.functionName)
}

// repeated .types.TreeNode inArgs = 2;
inline int FunctionNode::inargs_size() const {
  return inargs_.size();
}
inline void FunctionNode::clear_inargs() {
  inargs_.Clear();
}
inline ::types::TreeNode* FunctionNode::mutable_inargs(int index) {
  // @@protoc_insertion_point(field_mutable:types.FunctionNode.inArgs)
  return inargs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::types::TreeNode >*
FunctionNode::mutable_inargs() {
  // @@protoc_insertion_point(field_mutable_list:types.FunctionNode.inArgs)
  return &inargs_;
}
inline const ::types::TreeNode& FunctionNode::inargs(int index) const {
  // @@protoc_insertion_point(field_get:types.FunctionNode.inArgs)
  return inargs_.Get(index);
}
inline ::types::TreeNode* FunctionNode::add_inargs() {
  // @@protoc_insertion_point(field_add:types.FunctionNode.inArgs)
  return inargs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::types::TreeNode >&
FunctionNode::inargs() const {
  // @@protoc_insertion_point(field_list:types.FunctionNode.inArgs)
  return inargs_;
}

// optional .types.ExtGandivaType returnType = 3;
inline bool FunctionNode::has_returntype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FunctionNode::clear_returntype() {
  if (returntype_ != nullptr) returntype_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::types::ExtGandivaType& FunctionNode::returntype() const {
  const ::types::ExtGandivaType* p = returntype_;
  // @@protoc_insertion_point(field_get:types.FunctionNode.returnType)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::ExtGandivaType*>(
      &::types::_ExtGandivaType_default_instance_);
}
inline ::types::ExtGandivaType* FunctionNode::release_returntype() {
  // @@protoc_insertion_point(field_release:types.FunctionNode.returnType)
  _has_bits_[0] &= ~0x00000002u;
  ::types::ExtGandivaType* temp = returntype_;
  returntype_ = nullptr;
  return temp;
}
inline ::types::ExtGandivaType* FunctionNode::mutable_returntype() {
  _has_bits_[0] |= 0x00000002u;
  if (returntype_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::ExtGandivaType>(GetArenaNoVirtual());
    returntype_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.FunctionNode.returnType)
  return returntype_;
}
inline void FunctionNode::set_allocated_returntype(::types::ExtGandivaType* returntype) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete returntype_;
  }
  if (returntype) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      returntype = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, returntype, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  returntype_ = returntype;
  // @@protoc_insertion_point(field_set_allocated:types.FunctionNode.returnType)
}

// -------------------------------------------------------------------

// IfNode

// optional .types.TreeNode cond = 1;
inline bool IfNode::has_cond() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IfNode::clear_cond() {
  if (cond_ != nullptr) cond_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::types::TreeNode& IfNode::cond() const {
  const ::types::TreeNode* p = cond_;
  // @@protoc_insertion_point(field_get:types.IfNode.cond)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::TreeNode*>(
      &::types::_TreeNode_default_instance_);
}
inline ::types::TreeNode* IfNode::release_cond() {
  // @@protoc_insertion_point(field_release:types.IfNode.cond)
  _has_bits_[0] &= ~0x00000001u;
  ::types::TreeNode* temp = cond_;
  cond_ = nullptr;
  return temp;
}
inline ::types::TreeNode* IfNode::mutable_cond() {
  _has_bits_[0] |= 0x00000001u;
  if (cond_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::TreeNode>(GetArenaNoVirtual());
    cond_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.IfNode.cond)
  return cond_;
}
inline void IfNode::set_allocated_cond(::types::TreeNode* cond) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete cond_;
  }
  if (cond) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      cond = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, cond, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  cond_ = cond;
  // @@protoc_insertion_point(field_set_allocated:types.IfNode.cond)
}

// optional .types.TreeNode thenNode = 2;
inline bool IfNode::has_thennode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void IfNode::clear_thennode() {
  if (thennode_ != nullptr) thennode_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::types::TreeNode& IfNode::thennode() const {
  const ::types::TreeNode* p = thennode_;
  // @@protoc_insertion_point(field_get:types.IfNode.thenNode)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::TreeNode*>(
      &::types::_TreeNode_default_instance_);
}
inline ::types::TreeNode* IfNode::release_thennode() {
  // @@protoc_insertion_point(field_release:types.IfNode.thenNode)
  _has_bits_[0] &= ~0x00000002u;
  ::types::TreeNode* temp = thennode_;
  thennode_ = nullptr;
  return temp;
}
inline ::types::TreeNode* IfNode::mutable_thennode() {
  _has_bits_[0] |= 0x00000002u;
  if (thennode_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::TreeNode>(GetArenaNoVirtual());
    thennode_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.IfNode.thenNode)
  return thennode_;
}
inline void IfNode::set_allocated_thennode(::types::TreeNode* thennode) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete thennode_;
  }
  if (thennode) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      thennode = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, thennode, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  thennode_ = thennode;
  // @@protoc_insertion_point(field_set_allocated:types.IfNode.thenNode)
}

// optional .types.TreeNode elseNode = 3;
inline bool IfNode::has_elsenode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void IfNode::clear_elsenode() {
  if (elsenode_ != nullptr) elsenode_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::types::TreeNode& IfNode::elsenode() const {
  const ::types::TreeNode* p = elsenode_;
  // @@protoc_insertion_point(field_get:types.IfNode.elseNode)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::TreeNode*>(
      &::types::_TreeNode_default_instance_);
}
inline ::types::TreeNode* IfNode::release_elsenode() {
  // @@protoc_insertion_point(field_release:types.IfNode.elseNode)
  _has_bits_[0] &= ~0x00000004u;
  ::types::TreeNode* temp = elsenode_;
  elsenode_ = nullptr;
  return temp;
}
inline ::types::TreeNode* IfNode::mutable_elsenode() {
  _has_bits_[0] |= 0x00000004u;
  if (elsenode_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::TreeNode>(GetArenaNoVirtual());
    elsenode_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.IfNode.elseNode)
  return elsenode_;
}
inline void IfNode::set_allocated_elsenode(::types::TreeNode* elsenode) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete elsenode_;
  }
  if (elsenode) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      elsenode = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, elsenode, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  elsenode_ = elsenode;
  // @@protoc_insertion_point(field_set_allocated:types.IfNode.elseNode)
}

// optional .types.ExtGandivaType returnType = 4;
inline bool IfNode::has_returntype() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void IfNode::clear_returntype() {
  if (returntype_ != nullptr) returntype_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::types::ExtGandivaType& IfNode::returntype() const {
  const ::types::ExtGandivaType* p = returntype_;
  // @@protoc_insertion_point(field_get:types.IfNode.returnType)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::ExtGandivaType*>(
      &::types::_ExtGandivaType_default_instance_);
}
inline ::types::ExtGandivaType* IfNode::release_returntype() {
  // @@protoc_insertion_point(field_release:types.IfNode.returnType)
  _has_bits_[0] &= ~0x00000008u;
  ::types::ExtGandivaType* temp = returntype_;
  returntype_ = nullptr;
  return temp;
}
inline ::types::ExtGandivaType* IfNode::mutable_returntype() {
  _has_bits_[0] |= 0x00000008u;
  if (returntype_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::ExtGandivaType>(GetArenaNoVirtual());
    returntype_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.IfNode.returnType)
  return returntype_;
}
inline void IfNode::set_allocated_returntype(::types::ExtGandivaType* returntype) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete returntype_;
  }
  if (returntype) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      returntype = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, returntype, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  returntype_ = returntype;
  // @@protoc_insertion_point(field_set_allocated:types.IfNode.returnType)
}

// -------------------------------------------------------------------

// AndNode

// repeated .types.TreeNode args = 1;
inline int AndNode::args_size() const {
  return args_.size();
}
inline void AndNode::clear_args() {
  args_.Clear();
}
inline ::types::TreeNode* AndNode::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:types.AndNode.args)
  return args_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::types::TreeNode >*
AndNode::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:types.AndNode.args)
  return &args_;
}
inline const ::types::TreeNode& AndNode::args(int index) const {
  // @@protoc_insertion_point(field_get:types.AndNode.args)
  return args_.Get(index);
}
inline ::types::TreeNode* AndNode::add_args() {
  // @@protoc_insertion_point(field_add:types.AndNode.args)
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::types::TreeNode >&
AndNode::args() const {
  // @@protoc_insertion_point(field_list:types.AndNode.args)
  return args_;
}

// -------------------------------------------------------------------

// OrNode

// repeated .types.TreeNode args = 1;
inline int OrNode::args_size() const {
  return args_.size();
}
inline void OrNode::clear_args() {
  args_.Clear();
}
inline ::types::TreeNode* OrNode::mutable_args(int index) {
  // @@protoc_insertion_point(field_mutable:types.OrNode.args)
  return args_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::types::TreeNode >*
OrNode::mutable_args() {
  // @@protoc_insertion_point(field_mutable_list:types.OrNode.args)
  return &args_;
}
inline const ::types::TreeNode& OrNode::args(int index) const {
  // @@protoc_insertion_point(field_get:types.OrNode.args)
  return args_.Get(index);
}
inline ::types::TreeNode* OrNode::add_args() {
  // @@protoc_insertion_point(field_add:types.OrNode.args)
  return args_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::types::TreeNode >&
OrNode::args() const {
  // @@protoc_insertion_point(field_list:types.OrNode.args)
  return args_;
}

// -------------------------------------------------------------------

// NullNode

// optional .types.ExtGandivaType type = 1;
inline bool NullNode::has_type() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void NullNode::clear_type() {
  if (type_ != nullptr) type_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::types::ExtGandivaType& NullNode::type() const {
  const ::types::ExtGandivaType* p = type_;
  // @@protoc_insertion_point(field_get:types.NullNode.type)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::ExtGandivaType*>(
      &::types::_ExtGandivaType_default_instance_);
}
inline ::types::ExtGandivaType* NullNode::release_type() {
  // @@protoc_insertion_point(field_release:types.NullNode.type)
  _has_bits_[0] &= ~0x00000001u;
  ::types::ExtGandivaType* temp = type_;
  type_ = nullptr;
  return temp;
}
inline ::types::ExtGandivaType* NullNode::mutable_type() {
  _has_bits_[0] |= 0x00000001u;
  if (type_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::ExtGandivaType>(GetArenaNoVirtual());
    type_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.NullNode.type)
  return type_;
}
inline void NullNode::set_allocated_type(::types::ExtGandivaType* type) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete type_;
  }
  if (type) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      type = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, type, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  type_ = type;
  // @@protoc_insertion_point(field_set_allocated:types.NullNode.type)
}

// -------------------------------------------------------------------

// IntNode

// optional int32 value = 1;
inline bool IntNode::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void IntNode::clear_value() {
  value_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::int32 IntNode::value() const {
  // @@protoc_insertion_point(field_get:types.IntNode.value)
  return value_;
}
inline void IntNode::set_value(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000001u;
  value_ = value;
  // @@protoc_insertion_point(field_set:types.IntNode.value)
}

// -------------------------------------------------------------------

// FloatNode

// optional float value = 1;
inline bool FloatNode::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FloatNode::clear_value() {
  value_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline float FloatNode::value() const {
  // @@protoc_insertion_point(field_get:types.FloatNode.value)
  return value_;
}
inline void FloatNode::set_value(float value) {
  _has_bits_[0] |= 0x00000001u;
  value_ = value;
  // @@protoc_insertion_point(field_set:types.FloatNode.value)
}

// -------------------------------------------------------------------

// DoubleNode

// optional double value = 1;
inline bool DoubleNode::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DoubleNode::clear_value() {
  value_ = 0;
  _has_bits_[0] &= ~0x00000001u;
}
inline double DoubleNode::value() const {
  // @@protoc_insertion_point(field_get:types.DoubleNode.value)
  return value_;
}
inline void DoubleNode::set_value(double value) {
  _has_bits_[0] |= 0x00000001u;
  value_ = value;
  // @@protoc_insertion_point(field_set:types.DoubleNode.value)
}

// -------------------------------------------------------------------

// BooleanNode

// optional bool value = 1;
inline bool BooleanNode::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BooleanNode::clear_value() {
  value_ = false;
  _has_bits_[0] &= ~0x00000001u;
}
inline bool BooleanNode::value() const {
  // @@protoc_insertion_point(field_get:types.BooleanNode.value)
  return value_;
}
inline void BooleanNode::set_value(bool value) {
  _has_bits_[0] |= 0x00000001u;
  value_ = value;
  // @@protoc_insertion_point(field_set:types.BooleanNode.value)
}

// -------------------------------------------------------------------

// LongNode

// optional int64 value = 1;
inline bool LongNode::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void LongNode::clear_value() {
  value_ = PROTOBUF_LONGLONG(0);
  _has_bits_[0] &= ~0x00000001u;
}
inline ::google::protobuf::int64 LongNode::value() const {
  // @@protoc_insertion_point(field_get:types.LongNode.value)
  return value_;
}
inline void LongNode::set_value(::google::protobuf::int64 value) {
  _has_bits_[0] |= 0x00000001u;
  value_ = value;
  // @@protoc_insertion_point(field_set:types.LongNode.value)
}

// -------------------------------------------------------------------

// StringNode

// optional bytes value = 1;
inline bool StringNode::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void StringNode::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& StringNode::value() const {
  // @@protoc_insertion_point(field_get:types.StringNode.value)
  return value_.GetNoArena();
}
inline void StringNode::set_value(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.StringNode.value)
}
#if LANG_CXX11
inline void StringNode::set_value(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.StringNode.value)
}
#endif
inline void StringNode::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.StringNode.value)
}
inline void StringNode::set_value(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.StringNode.value)
}
inline ::std::string* StringNode::mutable_value() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:types.StringNode.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* StringNode::release_value() {
  // @@protoc_insertion_point(field_release:types.StringNode.value)
  if (!has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return value_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void StringNode::set_allocated_value(::std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:types.StringNode.value)
}

// -------------------------------------------------------------------

// BinaryNode

// optional bytes value = 1;
inline bool BinaryNode::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void BinaryNode::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& BinaryNode::value() const {
  // @@protoc_insertion_point(field_get:types.BinaryNode.value)
  return value_.GetNoArena();
}
inline void BinaryNode::set_value(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.BinaryNode.value)
}
#if LANG_CXX11
inline void BinaryNode::set_value(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.BinaryNode.value)
}
#endif
inline void BinaryNode::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.BinaryNode.value)
}
inline void BinaryNode::set_value(const void* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.BinaryNode.value)
}
inline ::std::string* BinaryNode::mutable_value() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:types.BinaryNode.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* BinaryNode::release_value() {
  // @@protoc_insertion_point(field_release:types.BinaryNode.value)
  if (!has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return value_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void BinaryNode::set_allocated_value(::std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:types.BinaryNode.value)
}

// -------------------------------------------------------------------

// DecimalNode

// optional string value = 1;
inline bool DecimalNode::has_value() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DecimalNode::clear_value() {
  value_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& DecimalNode::value() const {
  // @@protoc_insertion_point(field_get:types.DecimalNode.value)
  return value_.GetNoArena();
}
inline void DecimalNode::set_value(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.DecimalNode.value)
}
#if LANG_CXX11
inline void DecimalNode::set_value(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  value_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.DecimalNode.value)
}
#endif
inline void DecimalNode::set_value(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.DecimalNode.value)
}
inline void DecimalNode::set_value(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  value_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.DecimalNode.value)
}
inline ::std::string* DecimalNode::mutable_value() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:types.DecimalNode.value)
  return value_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* DecimalNode::release_value() {
  // @@protoc_insertion_point(field_release:types.DecimalNode.value)
  if (!has_value()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return value_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void DecimalNode::set_allocated_value(::std::string* value) {
  if (value != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  value_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set_allocated:types.DecimalNode.value)
}

// optional int32 precision = 2;
inline bool DecimalNode::has_precision() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DecimalNode::clear_precision() {
  precision_ = 0;
  _has_bits_[0] &= ~0x00000002u;
}
inline ::google::protobuf::int32 DecimalNode::precision() const {
  // @@protoc_insertion_point(field_get:types.DecimalNode.precision)
  return precision_;
}
inline void DecimalNode::set_precision(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000002u;
  precision_ = value;
  // @@protoc_insertion_point(field_set:types.DecimalNode.precision)
}

// optional int32 scale = 3;
inline bool DecimalNode::has_scale() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DecimalNode::clear_scale() {
  scale_ = 0;
  _has_bits_[0] &= ~0x00000004u;
}
inline ::google::protobuf::int32 DecimalNode::scale() const {
  // @@protoc_insertion_point(field_get:types.DecimalNode.scale)
  return scale_;
}
inline void DecimalNode::set_scale(::google::protobuf::int32 value) {
  _has_bits_[0] |= 0x00000004u;
  scale_ = value;
  // @@protoc_insertion_point(field_set:types.DecimalNode.scale)
}

// -------------------------------------------------------------------

// TreeNode

// optional .types.FieldNode fieldNode = 1;
inline bool TreeNode::has_fieldnode() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void TreeNode::clear_fieldnode() {
  if (fieldnode_ != nullptr) fieldnode_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::types::FieldNode& TreeNode::fieldnode() const {
  const ::types::FieldNode* p = fieldnode_;
  // @@protoc_insertion_point(field_get:types.TreeNode.fieldNode)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::FieldNode*>(
      &::types::_FieldNode_default_instance_);
}
inline ::types::FieldNode* TreeNode::release_fieldnode() {
  // @@protoc_insertion_point(field_release:types.TreeNode.fieldNode)
  _has_bits_[0] &= ~0x00000001u;
  ::types::FieldNode* temp = fieldnode_;
  fieldnode_ = nullptr;
  return temp;
}
inline ::types::FieldNode* TreeNode::mutable_fieldnode() {
  _has_bits_[0] |= 0x00000001u;
  if (fieldnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::FieldNode>(GetArenaNoVirtual());
    fieldnode_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.TreeNode.fieldNode)
  return fieldnode_;
}
inline void TreeNode::set_allocated_fieldnode(::types::FieldNode* fieldnode) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete fieldnode_;
  }
  if (fieldnode) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      fieldnode = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fieldnode, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  fieldnode_ = fieldnode;
  // @@protoc_insertion_point(field_set_allocated:types.TreeNode.fieldNode)
}

// optional .types.FunctionNode fnNode = 2;
inline bool TreeNode::has_fnnode() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void TreeNode::clear_fnnode() {
  if (fnnode_ != nullptr) fnnode_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::types::FunctionNode& TreeNode::fnnode() const {
  const ::types::FunctionNode* p = fnnode_;
  // @@protoc_insertion_point(field_get:types.TreeNode.fnNode)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::FunctionNode*>(
      &::types::_FunctionNode_default_instance_);
}
inline ::types::FunctionNode* TreeNode::release_fnnode() {
  // @@protoc_insertion_point(field_release:types.TreeNode.fnNode)
  _has_bits_[0] &= ~0x00000002u;
  ::types::FunctionNode* temp = fnnode_;
  fnnode_ = nullptr;
  return temp;
}
inline ::types::FunctionNode* TreeNode::mutable_fnnode() {
  _has_bits_[0] |= 0x00000002u;
  if (fnnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::FunctionNode>(GetArenaNoVirtual());
    fnnode_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.TreeNode.fnNode)
  return fnnode_;
}
inline void TreeNode::set_allocated_fnnode(::types::FunctionNode* fnnode) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete fnnode_;
  }
  if (fnnode) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      fnnode = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, fnnode, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  fnnode_ = fnnode;
  // @@protoc_insertion_point(field_set_allocated:types.TreeNode.fnNode)
}

// optional .types.IfNode ifNode = 6;
inline bool TreeNode::has_ifnode() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void TreeNode::clear_ifnode() {
  if (ifnode_ != nullptr) ifnode_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::types::IfNode& TreeNode::ifnode() const {
  const ::types::IfNode* p = ifnode_;
  // @@protoc_insertion_point(field_get:types.TreeNode.ifNode)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::IfNode*>(
      &::types::_IfNode_default_instance_);
}
inline ::types::IfNode* TreeNode::release_ifnode() {
  // @@protoc_insertion_point(field_release:types.TreeNode.ifNode)
  _has_bits_[0] &= ~0x00000004u;
  ::types::IfNode* temp = ifnode_;
  ifnode_ = nullptr;
  return temp;
}
inline ::types::IfNode* TreeNode::mutable_ifnode() {
  _has_bits_[0] |= 0x00000004u;
  if (ifnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::IfNode>(GetArenaNoVirtual());
    ifnode_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.TreeNode.ifNode)
  return ifnode_;
}
inline void TreeNode::set_allocated_ifnode(::types::IfNode* ifnode) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete ifnode_;
  }
  if (ifnode) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ifnode = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ifnode, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  ifnode_ = ifnode;
  // @@protoc_insertion_point(field_set_allocated:types.TreeNode.ifNode)
}

// optional .types.AndNode andNode = 7;
inline bool TreeNode::has_andnode() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void TreeNode::clear_andnode() {
  if (andnode_ != nullptr) andnode_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::types::AndNode& TreeNode::andnode() const {
  const ::types::AndNode* p = andnode_;
  // @@protoc_insertion_point(field_get:types.TreeNode.andNode)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::AndNode*>(
      &::types::_AndNode_default_instance_);
}
inline ::types::AndNode* TreeNode::release_andnode() {
  // @@protoc_insertion_point(field_release:types.TreeNode.andNode)
  _has_bits_[0] &= ~0x00000008u;
  ::types::AndNode* temp = andnode_;
  andnode_ = nullptr;
  return temp;
}
inline ::types::AndNode* TreeNode::mutable_andnode() {
  _has_bits_[0] |= 0x00000008u;
  if (andnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::AndNode>(GetArenaNoVirtual());
    andnode_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.TreeNode.andNode)
  return andnode_;
}
inline void TreeNode::set_allocated_andnode(::types::AndNode* andnode) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete andnode_;
  }
  if (andnode) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      andnode = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, andnode, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  andnode_ = andnode;
  // @@protoc_insertion_point(field_set_allocated:types.TreeNode.andNode)
}

// optional .types.OrNode orNode = 8;
inline bool TreeNode::has_ornode() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void TreeNode::clear_ornode() {
  if (ornode_ != nullptr) ornode_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::types::OrNode& TreeNode::ornode() const {
  const ::types::OrNode* p = ornode_;
  // @@protoc_insertion_point(field_get:types.TreeNode.orNode)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::OrNode*>(
      &::types::_OrNode_default_instance_);
}
inline ::types::OrNode* TreeNode::release_ornode() {
  // @@protoc_insertion_point(field_release:types.TreeNode.orNode)
  _has_bits_[0] &= ~0x00000010u;
  ::types::OrNode* temp = ornode_;
  ornode_ = nullptr;
  return temp;
}
inline ::types::OrNode* TreeNode::mutable_ornode() {
  _has_bits_[0] |= 0x00000010u;
  if (ornode_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::OrNode>(GetArenaNoVirtual());
    ornode_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.TreeNode.orNode)
  return ornode_;
}
inline void TreeNode::set_allocated_ornode(::types::OrNode* ornode) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete ornode_;
  }
  if (ornode) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      ornode = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, ornode, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  ornode_ = ornode;
  // @@protoc_insertion_point(field_set_allocated:types.TreeNode.orNode)
}

// optional .types.NullNode nullNode = 11;
inline bool TreeNode::has_nullnode() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void TreeNode::clear_nullnode() {
  if (nullnode_ != nullptr) nullnode_->Clear();
  _has_bits_[0] &= ~0x00000020u;
}
inline const ::types::NullNode& TreeNode::nullnode() const {
  const ::types::NullNode* p = nullnode_;
  // @@protoc_insertion_point(field_get:types.TreeNode.nullNode)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::NullNode*>(
      &::types::_NullNode_default_instance_);
}
inline ::types::NullNode* TreeNode::release_nullnode() {
  // @@protoc_insertion_point(field_release:types.TreeNode.nullNode)
  _has_bits_[0] &= ~0x00000020u;
  ::types::NullNode* temp = nullnode_;
  nullnode_ = nullptr;
  return temp;
}
inline ::types::NullNode* TreeNode::mutable_nullnode() {
  _has_bits_[0] |= 0x00000020u;
  if (nullnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::NullNode>(GetArenaNoVirtual());
    nullnode_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.TreeNode.nullNode)
  return nullnode_;
}
inline void TreeNode::set_allocated_nullnode(::types::NullNode* nullnode) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete nullnode_;
  }
  if (nullnode) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      nullnode = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, nullnode, submessage_arena);
    }
    _has_bits_[0] |= 0x00000020u;
  } else {
    _has_bits_[0] &= ~0x00000020u;
  }
  nullnode_ = nullnode;
  // @@protoc_insertion_point(field_set_allocated:types.TreeNode.nullNode)
}

// optional .types.IntNode intNode = 12;
inline bool TreeNode::has_intnode() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void TreeNode::clear_intnode() {
  if (intnode_ != nullptr) intnode_->Clear();
  _has_bits_[0] &= ~0x00000040u;
}
inline const ::types::IntNode& TreeNode::intnode() const {
  const ::types::IntNode* p = intnode_;
  // @@protoc_insertion_point(field_get:types.TreeNode.intNode)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::IntNode*>(
      &::types::_IntNode_default_instance_);
}
inline ::types::IntNode* TreeNode::release_intnode() {
  // @@protoc_insertion_point(field_release:types.TreeNode.intNode)
  _has_bits_[0] &= ~0x00000040u;
  ::types::IntNode* temp = intnode_;
  intnode_ = nullptr;
  return temp;
}
inline ::types::IntNode* TreeNode::mutable_intnode() {
  _has_bits_[0] |= 0x00000040u;
  if (intnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::IntNode>(GetArenaNoVirtual());
    intnode_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.TreeNode.intNode)
  return intnode_;
}
inline void TreeNode::set_allocated_intnode(::types::IntNode* intnode) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete intnode_;
  }
  if (intnode) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      intnode = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, intnode, submessage_arena);
    }
    _has_bits_[0] |= 0x00000040u;
  } else {
    _has_bits_[0] &= ~0x00000040u;
  }
  intnode_ = intnode;
  // @@protoc_insertion_point(field_set_allocated:types.TreeNode.intNode)
}

// optional .types.FloatNode floatNode = 13;
inline bool TreeNode::has_floatnode() const {
  return (_has_bits_[0] & 0x00000080u) != 0;
}
inline void TreeNode::clear_floatnode() {
  if (floatnode_ != nullptr) floatnode_->Clear();
  _has_bits_[0] &= ~0x00000080u;
}
inline const ::types::FloatNode& TreeNode::floatnode() const {
  const ::types::FloatNode* p = floatnode_;
  // @@protoc_insertion_point(field_get:types.TreeNode.floatNode)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::FloatNode*>(
      &::types::_FloatNode_default_instance_);
}
inline ::types::FloatNode* TreeNode::release_floatnode() {
  // @@protoc_insertion_point(field_release:types.TreeNode.floatNode)
  _has_bits_[0] &= ~0x00000080u;
  ::types::FloatNode* temp = floatnode_;
  floatnode_ = nullptr;
  return temp;
}
inline ::types::FloatNode* TreeNode::mutable_floatnode() {
  _has_bits_[0] |= 0x00000080u;
  if (floatnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::FloatNode>(GetArenaNoVirtual());
    floatnode_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.TreeNode.floatNode)
  return floatnode_;
}
inline void TreeNode::set_allocated_floatnode(::types::FloatNode* floatnode) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete floatnode_;
  }
  if (floatnode) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      floatnode = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, floatnode, submessage_arena);
    }
    _has_bits_[0] |= 0x00000080u;
  } else {
    _has_bits_[0] &= ~0x00000080u;
  }
  floatnode_ = floatnode;
  // @@protoc_insertion_point(field_set_allocated:types.TreeNode.floatNode)
}

// optional .types.LongNode longNode = 14;
inline bool TreeNode::has_longnode() const {
  return (_has_bits_[0] & 0x00000100u) != 0;
}
inline void TreeNode::clear_longnode() {
  if (longnode_ != nullptr) longnode_->Clear();
  _has_bits_[0] &= ~0x00000100u;
}
inline const ::types::LongNode& TreeNode::longnode() const {
  const ::types::LongNode* p = longnode_;
  // @@protoc_insertion_point(field_get:types.TreeNode.longNode)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::LongNode*>(
      &::types::_LongNode_default_instance_);
}
inline ::types::LongNode* TreeNode::release_longnode() {
  // @@protoc_insertion_point(field_release:types.TreeNode.longNode)
  _has_bits_[0] &= ~0x00000100u;
  ::types::LongNode* temp = longnode_;
  longnode_ = nullptr;
  return temp;
}
inline ::types::LongNode* TreeNode::mutable_longnode() {
  _has_bits_[0] |= 0x00000100u;
  if (longnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::LongNode>(GetArenaNoVirtual());
    longnode_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.TreeNode.longNode)
  return longnode_;
}
inline void TreeNode::set_allocated_longnode(::types::LongNode* longnode) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete longnode_;
  }
  if (longnode) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      longnode = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, longnode, submessage_arena);
    }
    _has_bits_[0] |= 0x00000100u;
  } else {
    _has_bits_[0] &= ~0x00000100u;
  }
  longnode_ = longnode;
  // @@protoc_insertion_point(field_set_allocated:types.TreeNode.longNode)
}

// optional .types.BooleanNode booleanNode = 15;
inline bool TreeNode::has_booleannode() const {
  return (_has_bits_[0] & 0x00000200u) != 0;
}
inline void TreeNode::clear_booleannode() {
  if (booleannode_ != nullptr) booleannode_->Clear();
  _has_bits_[0] &= ~0x00000200u;
}
inline const ::types::BooleanNode& TreeNode::booleannode() const {
  const ::types::BooleanNode* p = booleannode_;
  // @@protoc_insertion_point(field_get:types.TreeNode.booleanNode)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::BooleanNode*>(
      &::types::_BooleanNode_default_instance_);
}
inline ::types::BooleanNode* TreeNode::release_booleannode() {
  // @@protoc_insertion_point(field_release:types.TreeNode.booleanNode)
  _has_bits_[0] &= ~0x00000200u;
  ::types::BooleanNode* temp = booleannode_;
  booleannode_ = nullptr;
  return temp;
}
inline ::types::BooleanNode* TreeNode::mutable_booleannode() {
  _has_bits_[0] |= 0x00000200u;
  if (booleannode_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::BooleanNode>(GetArenaNoVirtual());
    booleannode_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.TreeNode.booleanNode)
  return booleannode_;
}
inline void TreeNode::set_allocated_booleannode(::types::BooleanNode* booleannode) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete booleannode_;
  }
  if (booleannode) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      booleannode = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, booleannode, submessage_arena);
    }
    _has_bits_[0] |= 0x00000200u;
  } else {
    _has_bits_[0] &= ~0x00000200u;
  }
  booleannode_ = booleannode;
  // @@protoc_insertion_point(field_set_allocated:types.TreeNode.booleanNode)
}

// optional .types.DoubleNode doubleNode = 16;
inline bool TreeNode::has_doublenode() const {
  return (_has_bits_[0] & 0x00000400u) != 0;
}
inline void TreeNode::clear_doublenode() {
  if (doublenode_ != nullptr) doublenode_->Clear();
  _has_bits_[0] &= ~0x00000400u;
}
inline const ::types::DoubleNode& TreeNode::doublenode() const {
  const ::types::DoubleNode* p = doublenode_;
  // @@protoc_insertion_point(field_get:types.TreeNode.doubleNode)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::DoubleNode*>(
      &::types::_DoubleNode_default_instance_);
}
inline ::types::DoubleNode* TreeNode::release_doublenode() {
  // @@protoc_insertion_point(field_release:types.TreeNode.doubleNode)
  _has_bits_[0] &= ~0x00000400u;
  ::types::DoubleNode* temp = doublenode_;
  doublenode_ = nullptr;
  return temp;
}
inline ::types::DoubleNode* TreeNode::mutable_doublenode() {
  _has_bits_[0] |= 0x00000400u;
  if (doublenode_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::DoubleNode>(GetArenaNoVirtual());
    doublenode_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.TreeNode.doubleNode)
  return doublenode_;
}
inline void TreeNode::set_allocated_doublenode(::types::DoubleNode* doublenode) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete doublenode_;
  }
  if (doublenode) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      doublenode = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, doublenode, submessage_arena);
    }
    _has_bits_[0] |= 0x00000400u;
  } else {
    _has_bits_[0] &= ~0x00000400u;
  }
  doublenode_ = doublenode;
  // @@protoc_insertion_point(field_set_allocated:types.TreeNode.doubleNode)
}

// optional .types.StringNode stringNode = 17;
inline bool TreeNode::has_stringnode() const {
  return (_has_bits_[0] & 0x00000800u) != 0;
}
inline void TreeNode::clear_stringnode() {
  if (stringnode_ != nullptr) stringnode_->Clear();
  _has_bits_[0] &= ~0x00000800u;
}
inline const ::types::StringNode& TreeNode::stringnode() const {
  const ::types::StringNode* p = stringnode_;
  // @@protoc_insertion_point(field_get:types.TreeNode.stringNode)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::StringNode*>(
      &::types::_StringNode_default_instance_);
}
inline ::types::StringNode* TreeNode::release_stringnode() {
  // @@protoc_insertion_point(field_release:types.TreeNode.stringNode)
  _has_bits_[0] &= ~0x00000800u;
  ::types::StringNode* temp = stringnode_;
  stringnode_ = nullptr;
  return temp;
}
inline ::types::StringNode* TreeNode::mutable_stringnode() {
  _has_bits_[0] |= 0x00000800u;
  if (stringnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::StringNode>(GetArenaNoVirtual());
    stringnode_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.TreeNode.stringNode)
  return stringnode_;
}
inline void TreeNode::set_allocated_stringnode(::types::StringNode* stringnode) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete stringnode_;
  }
  if (stringnode) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      stringnode = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stringnode, submessage_arena);
    }
    _has_bits_[0] |= 0x00000800u;
  } else {
    _has_bits_[0] &= ~0x00000800u;
  }
  stringnode_ = stringnode;
  // @@protoc_insertion_point(field_set_allocated:types.TreeNode.stringNode)
}

// optional .types.BinaryNode binaryNode = 18;
inline bool TreeNode::has_binarynode() const {
  return (_has_bits_[0] & 0x00001000u) != 0;
}
inline void TreeNode::clear_binarynode() {
  if (binarynode_ != nullptr) binarynode_->Clear();
  _has_bits_[0] &= ~0x00001000u;
}
inline const ::types::BinaryNode& TreeNode::binarynode() const {
  const ::types::BinaryNode* p = binarynode_;
  // @@protoc_insertion_point(field_get:types.TreeNode.binaryNode)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::BinaryNode*>(
      &::types::_BinaryNode_default_instance_);
}
inline ::types::BinaryNode* TreeNode::release_binarynode() {
  // @@protoc_insertion_point(field_release:types.TreeNode.binaryNode)
  _has_bits_[0] &= ~0x00001000u;
  ::types::BinaryNode* temp = binarynode_;
  binarynode_ = nullptr;
  return temp;
}
inline ::types::BinaryNode* TreeNode::mutable_binarynode() {
  _has_bits_[0] |= 0x00001000u;
  if (binarynode_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::BinaryNode>(GetArenaNoVirtual());
    binarynode_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.TreeNode.binaryNode)
  return binarynode_;
}
inline void TreeNode::set_allocated_binarynode(::types::BinaryNode* binarynode) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete binarynode_;
  }
  if (binarynode) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      binarynode = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, binarynode, submessage_arena);
    }
    _has_bits_[0] |= 0x00001000u;
  } else {
    _has_bits_[0] &= ~0x00001000u;
  }
  binarynode_ = binarynode;
  // @@protoc_insertion_point(field_set_allocated:types.TreeNode.binaryNode)
}

// optional .types.DecimalNode decimalNode = 19;
inline bool TreeNode::has_decimalnode() const {
  return (_has_bits_[0] & 0x00002000u) != 0;
}
inline void TreeNode::clear_decimalnode() {
  if (decimalnode_ != nullptr) decimalnode_->Clear();
  _has_bits_[0] &= ~0x00002000u;
}
inline const ::types::DecimalNode& TreeNode::decimalnode() const {
  const ::types::DecimalNode* p = decimalnode_;
  // @@protoc_insertion_point(field_get:types.TreeNode.decimalNode)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::DecimalNode*>(
      &::types::_DecimalNode_default_instance_);
}
inline ::types::DecimalNode* TreeNode::release_decimalnode() {
  // @@protoc_insertion_point(field_release:types.TreeNode.decimalNode)
  _has_bits_[0] &= ~0x00002000u;
  ::types::DecimalNode* temp = decimalnode_;
  decimalnode_ = nullptr;
  return temp;
}
inline ::types::DecimalNode* TreeNode::mutable_decimalnode() {
  _has_bits_[0] |= 0x00002000u;
  if (decimalnode_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::DecimalNode>(GetArenaNoVirtual());
    decimalnode_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.TreeNode.decimalNode)
  return decimalnode_;
}
inline void TreeNode::set_allocated_decimalnode(::types::DecimalNode* decimalnode) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete decimalnode_;
  }
  if (decimalnode) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      decimalnode = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, decimalnode, submessage_arena);
    }
    _has_bits_[0] |= 0x00002000u;
  } else {
    _has_bits_[0] &= ~0x00002000u;
  }
  decimalnode_ = decimalnode;
  // @@protoc_insertion_point(field_set_allocated:types.TreeNode.decimalNode)
}

// optional .types.InNode inNode = 21;
inline bool TreeNode::has_innode() const {
  return (_has_bits_[0] & 0x00004000u) != 0;
}
inline void TreeNode::clear_innode() {
  if (innode_ != nullptr) innode_->Clear();
  _has_bits_[0] &= ~0x00004000u;
}
inline const ::types::InNode& TreeNode::innode() const {
  const ::types::InNode* p = innode_;
  // @@protoc_insertion_point(field_get:types.TreeNode.inNode)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::InNode*>(
      &::types::_InNode_default_instance_);
}
inline ::types::InNode* TreeNode::release_innode() {
  // @@protoc_insertion_point(field_release:types.TreeNode.inNode)
  _has_bits_[0] &= ~0x00004000u;
  ::types::InNode* temp = innode_;
  innode_ = nullptr;
  return temp;
}
inline ::types::InNode* TreeNode::mutable_innode() {
  _has_bits_[0] |= 0x00004000u;
  if (innode_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::InNode>(GetArenaNoVirtual());
    innode_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.TreeNode.inNode)
  return innode_;
}
inline void TreeNode::set_allocated_innode(::types::InNode* innode) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete innode_;
  }
  if (innode) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      innode = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, innode, submessage_arena);
    }
    _has_bits_[0] |= 0x00004000u;
  } else {
    _has_bits_[0] &= ~0x00004000u;
  }
  innode_ = innode;
  // @@protoc_insertion_point(field_set_allocated:types.TreeNode.inNode)
}

// -------------------------------------------------------------------

// ExpressionRoot

// optional .types.TreeNode root = 1;
inline bool ExpressionRoot::has_root() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void ExpressionRoot::clear_root() {
  if (root_ != nullptr) root_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::types::TreeNode& ExpressionRoot::root() const {
  const ::types::TreeNode* p = root_;
  // @@protoc_insertion_point(field_get:types.ExpressionRoot.root)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::TreeNode*>(
      &::types::_TreeNode_default_instance_);
}
inline ::types::TreeNode* ExpressionRoot::release_root() {
  // @@protoc_insertion_point(field_release:types.ExpressionRoot.root)
  _has_bits_[0] &= ~0x00000001u;
  ::types::TreeNode* temp = root_;
  root_ = nullptr;
  return temp;
}
inline ::types::TreeNode* ExpressionRoot::mutable_root() {
  _has_bits_[0] |= 0x00000001u;
  if (root_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::TreeNode>(GetArenaNoVirtual());
    root_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.ExpressionRoot.root)
  return root_;
}
inline void ExpressionRoot::set_allocated_root(::types::TreeNode* root) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete root_;
  }
  if (root) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      root = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, root, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  root_ = root;
  // @@protoc_insertion_point(field_set_allocated:types.ExpressionRoot.root)
}

// optional .types.Field resultType = 2;
inline bool ExpressionRoot::has_resulttype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void ExpressionRoot::clear_resulttype() {
  if (resulttype_ != nullptr) resulttype_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::types::Field& ExpressionRoot::resulttype() const {
  const ::types::Field* p = resulttype_;
  // @@protoc_insertion_point(field_get:types.ExpressionRoot.resultType)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::Field*>(
      &::types::_Field_default_instance_);
}
inline ::types::Field* ExpressionRoot::release_resulttype() {
  // @@protoc_insertion_point(field_release:types.ExpressionRoot.resultType)
  _has_bits_[0] &= ~0x00000002u;
  ::types::Field* temp = resulttype_;
  resulttype_ = nullptr;
  return temp;
}
inline ::types::Field* ExpressionRoot::mutable_resulttype() {
  _has_bits_[0] |= 0x00000002u;
  if (resulttype_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::Field>(GetArenaNoVirtual());
    resulttype_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.ExpressionRoot.resultType)
  return resulttype_;
}
inline void ExpressionRoot::set_allocated_resulttype(::types::Field* resulttype) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete resulttype_;
  }
  if (resulttype) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      resulttype = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, resulttype, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  resulttype_ = resulttype;
  // @@protoc_insertion_point(field_set_allocated:types.ExpressionRoot.resultType)
}

// -------------------------------------------------------------------

// ExpressionList

// repeated .types.ExpressionRoot exprs = 2;
inline int ExpressionList::exprs_size() const {
  return exprs_.size();
}
inline void ExpressionList::clear_exprs() {
  exprs_.Clear();
}
inline ::types::ExpressionRoot* ExpressionList::mutable_exprs(int index) {
  // @@protoc_insertion_point(field_mutable:types.ExpressionList.exprs)
  return exprs_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::types::ExpressionRoot >*
ExpressionList::mutable_exprs() {
  // @@protoc_insertion_point(field_mutable_list:types.ExpressionList.exprs)
  return &exprs_;
}
inline const ::types::ExpressionRoot& ExpressionList::exprs(int index) const {
  // @@protoc_insertion_point(field_get:types.ExpressionList.exprs)
  return exprs_.Get(index);
}
inline ::types::ExpressionRoot* ExpressionList::add_exprs() {
  // @@protoc_insertion_point(field_add:types.ExpressionList.exprs)
  return exprs_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::types::ExpressionRoot >&
ExpressionList::exprs() const {
  // @@protoc_insertion_point(field_list:types.ExpressionList.exprs)
  return exprs_;
}

// -------------------------------------------------------------------

// Condition

// optional .types.TreeNode root = 1;
inline bool Condition::has_root() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Condition::clear_root() {
  if (root_ != nullptr) root_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::types::TreeNode& Condition::root() const {
  const ::types::TreeNode* p = root_;
  // @@protoc_insertion_point(field_get:types.Condition.root)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::TreeNode*>(
      &::types::_TreeNode_default_instance_);
}
inline ::types::TreeNode* Condition::release_root() {
  // @@protoc_insertion_point(field_release:types.Condition.root)
  _has_bits_[0] &= ~0x00000001u;
  ::types::TreeNode* temp = root_;
  root_ = nullptr;
  return temp;
}
inline ::types::TreeNode* Condition::mutable_root() {
  _has_bits_[0] |= 0x00000001u;
  if (root_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::TreeNode>(GetArenaNoVirtual());
    root_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.Condition.root)
  return root_;
}
inline void Condition::set_allocated_root(::types::TreeNode* root) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete root_;
  }
  if (root) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      root = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, root, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  root_ = root;
  // @@protoc_insertion_point(field_set_allocated:types.Condition.root)
}

// -------------------------------------------------------------------

// Schema

// repeated .types.Field columns = 1;
inline int Schema::columns_size() const {
  return columns_.size();
}
inline void Schema::clear_columns() {
  columns_.Clear();
}
inline ::types::Field* Schema::mutable_columns(int index) {
  // @@protoc_insertion_point(field_mutable:types.Schema.columns)
  return columns_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::types::Field >*
Schema::mutable_columns() {
  // @@protoc_insertion_point(field_mutable_list:types.Schema.columns)
  return &columns_;
}
inline const ::types::Field& Schema::columns(int index) const {
  // @@protoc_insertion_point(field_get:types.Schema.columns)
  return columns_.Get(index);
}
inline ::types::Field* Schema::add_columns() {
  // @@protoc_insertion_point(field_add:types.Schema.columns)
  return columns_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::types::Field >&
Schema::columns() const {
  // @@protoc_insertion_point(field_list:types.Schema.columns)
  return columns_;
}

// -------------------------------------------------------------------

// GandivaDataTypes

// repeated .types.ExtGandivaType dataType = 1;
inline int GandivaDataTypes::datatype_size() const {
  return datatype_.size();
}
inline void GandivaDataTypes::clear_datatype() {
  datatype_.Clear();
}
inline ::types::ExtGandivaType* GandivaDataTypes::mutable_datatype(int index) {
  // @@protoc_insertion_point(field_mutable:types.GandivaDataTypes.dataType)
  return datatype_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::types::ExtGandivaType >*
GandivaDataTypes::mutable_datatype() {
  // @@protoc_insertion_point(field_mutable_list:types.GandivaDataTypes.dataType)
  return &datatype_;
}
inline const ::types::ExtGandivaType& GandivaDataTypes::datatype(int index) const {
  // @@protoc_insertion_point(field_get:types.GandivaDataTypes.dataType)
  return datatype_.Get(index);
}
inline ::types::ExtGandivaType* GandivaDataTypes::add_datatype() {
  // @@protoc_insertion_point(field_add:types.GandivaDataTypes.dataType)
  return datatype_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::types::ExtGandivaType >&
GandivaDataTypes::datatype() const {
  // @@protoc_insertion_point(field_list:types.GandivaDataTypes.dataType)
  return datatype_;
}

// -------------------------------------------------------------------

// GandivaFunctions

// repeated .types.FunctionSignature function = 1;
inline int GandivaFunctions::function_size() const {
  return function_.size();
}
inline void GandivaFunctions::clear_function() {
  function_.Clear();
}
inline ::types::FunctionSignature* GandivaFunctions::mutable_function(int index) {
  // @@protoc_insertion_point(field_mutable:types.GandivaFunctions.function)
  return function_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::types::FunctionSignature >*
GandivaFunctions::mutable_function() {
  // @@protoc_insertion_point(field_mutable_list:types.GandivaFunctions.function)
  return &function_;
}
inline const ::types::FunctionSignature& GandivaFunctions::function(int index) const {
  // @@protoc_insertion_point(field_get:types.GandivaFunctions.function)
  return function_.Get(index);
}
inline ::types::FunctionSignature* GandivaFunctions::add_function() {
  // @@protoc_insertion_point(field_add:types.GandivaFunctions.function)
  return function_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::types::FunctionSignature >&
GandivaFunctions::function() const {
  // @@protoc_insertion_point(field_list:types.GandivaFunctions.function)
  return function_;
}

// -------------------------------------------------------------------

// FunctionSignature

// optional string name = 1;
inline bool FunctionSignature::has_name() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void FunctionSignature::clear_name() {
  name_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::std::string& FunctionSignature::name() const {
  // @@protoc_insertion_point(field_get:types.FunctionSignature.name)
  return name_.GetNoArena();
}
inline void FunctionSignature::set_name(const ::std::string& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:types.FunctionSignature.name)
}
#if LANG_CXX11
inline void FunctionSignature::set_name(::std::string&& value) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(
    &::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::move(value));
  // @@protoc_insertion_point(field_set_rvalue:types.FunctionSignature.name)
}
#endif
inline void FunctionSignature::set_name(const char* value) {
  GOOGLE_DCHECK(value != nullptr);
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:types.FunctionSignature.name)
}
inline void FunctionSignature::set_name(const char* value, size_t size) {
  _has_bits_[0] |= 0x00000001u;
  name_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:types.FunctionSignature.name)
}
inline ::std::string* FunctionSignature::mutable_name() {
  _has_bits_[0] |= 0x00000001u;
  // @@protoc_insertion_point(field_mutable:types.FunctionSignature.name)
  return name_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* FunctionSignature::release_name() {
  // @@protoc_insertion_point(field_release:types.FunctionSignature.name)
  if (!has_name()) {
    return nullptr;
  }
  _has_bits_[0] &= ~0x00000001u;
  return name_.ReleaseNonDefaultNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void FunctionSignature::set_allocated_name(::std::string* name) {
  if (name != nullptr) {
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  name_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), name);
  // @@protoc_insertion_point(field_set_allocated:types.FunctionSignature.name)
}

// optional .types.ExtGandivaType returnType = 2;
inline bool FunctionSignature::has_returntype() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void FunctionSignature::clear_returntype() {
  if (returntype_ != nullptr) returntype_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::types::ExtGandivaType& FunctionSignature::returntype() const {
  const ::types::ExtGandivaType* p = returntype_;
  // @@protoc_insertion_point(field_get:types.FunctionSignature.returnType)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::ExtGandivaType*>(
      &::types::_ExtGandivaType_default_instance_);
}
inline ::types::ExtGandivaType* FunctionSignature::release_returntype() {
  // @@protoc_insertion_point(field_release:types.FunctionSignature.returnType)
  _has_bits_[0] &= ~0x00000002u;
  ::types::ExtGandivaType* temp = returntype_;
  returntype_ = nullptr;
  return temp;
}
inline ::types::ExtGandivaType* FunctionSignature::mutable_returntype() {
  _has_bits_[0] |= 0x00000002u;
  if (returntype_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::ExtGandivaType>(GetArenaNoVirtual());
    returntype_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.FunctionSignature.returnType)
  return returntype_;
}
inline void FunctionSignature::set_allocated_returntype(::types::ExtGandivaType* returntype) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete returntype_;
  }
  if (returntype) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      returntype = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, returntype, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  returntype_ = returntype;
  // @@protoc_insertion_point(field_set_allocated:types.FunctionSignature.returnType)
}

// repeated .types.ExtGandivaType paramTypes = 3;
inline int FunctionSignature::paramtypes_size() const {
  return paramtypes_.size();
}
inline void FunctionSignature::clear_paramtypes() {
  paramtypes_.Clear();
}
inline ::types::ExtGandivaType* FunctionSignature::mutable_paramtypes(int index) {
  // @@protoc_insertion_point(field_mutable:types.FunctionSignature.paramTypes)
  return paramtypes_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::types::ExtGandivaType >*
FunctionSignature::mutable_paramtypes() {
  // @@protoc_insertion_point(field_mutable_list:types.FunctionSignature.paramTypes)
  return &paramtypes_;
}
inline const ::types::ExtGandivaType& FunctionSignature::paramtypes(int index) const {
  // @@protoc_insertion_point(field_get:types.FunctionSignature.paramTypes)
  return paramtypes_.Get(index);
}
inline ::types::ExtGandivaType* FunctionSignature::add_paramtypes() {
  // @@protoc_insertion_point(field_add:types.FunctionSignature.paramTypes)
  return paramtypes_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::types::ExtGandivaType >&
FunctionSignature::paramtypes() const {
  // @@protoc_insertion_point(field_list:types.FunctionSignature.paramTypes)
  return paramtypes_;
}

// -------------------------------------------------------------------

// InNode

// optional .types.FieldNode field = 1;
inline bool InNode::has_field() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void InNode::clear_field() {
  if (field_ != nullptr) field_->Clear();
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::types::FieldNode& InNode::field() const {
  const ::types::FieldNode* p = field_;
  // @@protoc_insertion_point(field_get:types.InNode.field)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::FieldNode*>(
      &::types::_FieldNode_default_instance_);
}
inline ::types::FieldNode* InNode::release_field() {
  // @@protoc_insertion_point(field_release:types.InNode.field)
  _has_bits_[0] &= ~0x00000001u;
  ::types::FieldNode* temp = field_;
  field_ = nullptr;
  return temp;
}
inline ::types::FieldNode* InNode::mutable_field() {
  _has_bits_[0] |= 0x00000001u;
  if (field_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::FieldNode>(GetArenaNoVirtual());
    field_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.InNode.field)
  return field_;
}
inline void InNode::set_allocated_field(::types::FieldNode* field) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete field_;
  }
  if (field) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      field = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, field, submessage_arena);
    }
    _has_bits_[0] |= 0x00000001u;
  } else {
    _has_bits_[0] &= ~0x00000001u;
  }
  field_ = field;
  // @@protoc_insertion_point(field_set_allocated:types.InNode.field)
}

// optional .types.IntConstants intValues = 2;
inline bool InNode::has_intvalues() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void InNode::clear_intvalues() {
  if (intvalues_ != nullptr) intvalues_->Clear();
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::types::IntConstants& InNode::intvalues() const {
  const ::types::IntConstants* p = intvalues_;
  // @@protoc_insertion_point(field_get:types.InNode.intValues)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::IntConstants*>(
      &::types::_IntConstants_default_instance_);
}
inline ::types::IntConstants* InNode::release_intvalues() {
  // @@protoc_insertion_point(field_release:types.InNode.intValues)
  _has_bits_[0] &= ~0x00000002u;
  ::types::IntConstants* temp = intvalues_;
  intvalues_ = nullptr;
  return temp;
}
inline ::types::IntConstants* InNode::mutable_intvalues() {
  _has_bits_[0] |= 0x00000002u;
  if (intvalues_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::IntConstants>(GetArenaNoVirtual());
    intvalues_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.InNode.intValues)
  return intvalues_;
}
inline void InNode::set_allocated_intvalues(::types::IntConstants* intvalues) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete intvalues_;
  }
  if (intvalues) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      intvalues = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, intvalues, submessage_arena);
    }
    _has_bits_[0] |= 0x00000002u;
  } else {
    _has_bits_[0] &= ~0x00000002u;
  }
  intvalues_ = intvalues;
  // @@protoc_insertion_point(field_set_allocated:types.InNode.intValues)
}

// optional .types.LongConstants longValues = 3;
inline bool InNode::has_longvalues() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void InNode::clear_longvalues() {
  if (longvalues_ != nullptr) longvalues_->Clear();
  _has_bits_[0] &= ~0x00000004u;
}
inline const ::types::LongConstants& InNode::longvalues() const {
  const ::types::LongConstants* p = longvalues_;
  // @@protoc_insertion_point(field_get:types.InNode.longValues)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::LongConstants*>(
      &::types::_LongConstants_default_instance_);
}
inline ::types::LongConstants* InNode::release_longvalues() {
  // @@protoc_insertion_point(field_release:types.InNode.longValues)
  _has_bits_[0] &= ~0x00000004u;
  ::types::LongConstants* temp = longvalues_;
  longvalues_ = nullptr;
  return temp;
}
inline ::types::LongConstants* InNode::mutable_longvalues() {
  _has_bits_[0] |= 0x00000004u;
  if (longvalues_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::LongConstants>(GetArenaNoVirtual());
    longvalues_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.InNode.longValues)
  return longvalues_;
}
inline void InNode::set_allocated_longvalues(::types::LongConstants* longvalues) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete longvalues_;
  }
  if (longvalues) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      longvalues = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, longvalues, submessage_arena);
    }
    _has_bits_[0] |= 0x00000004u;
  } else {
    _has_bits_[0] &= ~0x00000004u;
  }
  longvalues_ = longvalues;
  // @@protoc_insertion_point(field_set_allocated:types.InNode.longValues)
}

// optional .types.StringConstants stringValues = 4;
inline bool InNode::has_stringvalues() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void InNode::clear_stringvalues() {
  if (stringvalues_ != nullptr) stringvalues_->Clear();
  _has_bits_[0] &= ~0x00000008u;
}
inline const ::types::StringConstants& InNode::stringvalues() const {
  const ::types::StringConstants* p = stringvalues_;
  // @@protoc_insertion_point(field_get:types.InNode.stringValues)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::StringConstants*>(
      &::types::_StringConstants_default_instance_);
}
inline ::types::StringConstants* InNode::release_stringvalues() {
  // @@protoc_insertion_point(field_release:types.InNode.stringValues)
  _has_bits_[0] &= ~0x00000008u;
  ::types::StringConstants* temp = stringvalues_;
  stringvalues_ = nullptr;
  return temp;
}
inline ::types::StringConstants* InNode::mutable_stringvalues() {
  _has_bits_[0] |= 0x00000008u;
  if (stringvalues_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::StringConstants>(GetArenaNoVirtual());
    stringvalues_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.InNode.stringValues)
  return stringvalues_;
}
inline void InNode::set_allocated_stringvalues(::types::StringConstants* stringvalues) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete stringvalues_;
  }
  if (stringvalues) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      stringvalues = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, stringvalues, submessage_arena);
    }
    _has_bits_[0] |= 0x00000008u;
  } else {
    _has_bits_[0] &= ~0x00000008u;
  }
  stringvalues_ = stringvalues;
  // @@protoc_insertion_point(field_set_allocated:types.InNode.stringValues)
}

// optional .types.BinaryConstants binaryValues = 5;
inline bool InNode::has_binaryvalues() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void InNode::clear_binaryvalues() {
  if (binaryvalues_ != nullptr) binaryvalues_->Clear();
  _has_bits_[0] &= ~0x00000010u;
}
inline const ::types::BinaryConstants& InNode::binaryvalues() const {
  const ::types::BinaryConstants* p = binaryvalues_;
  // @@protoc_insertion_point(field_get:types.InNode.binaryValues)
  return p != nullptr ? *p : *reinterpret_cast<const ::types::BinaryConstants*>(
      &::types::_BinaryConstants_default_instance_);
}
inline ::types::BinaryConstants* InNode::release_binaryvalues() {
  // @@protoc_insertion_point(field_release:types.InNode.binaryValues)
  _has_bits_[0] &= ~0x00000010u;
  ::types::BinaryConstants* temp = binaryvalues_;
  binaryvalues_ = nullptr;
  return temp;
}
inline ::types::BinaryConstants* InNode::mutable_binaryvalues() {
  _has_bits_[0] |= 0x00000010u;
  if (binaryvalues_ == nullptr) {
    auto* p = CreateMaybeMessage<::types::BinaryConstants>(GetArenaNoVirtual());
    binaryvalues_ = p;
  }
  // @@protoc_insertion_point(field_mutable:types.InNode.binaryValues)
  return binaryvalues_;
}
inline void InNode::set_allocated_binaryvalues(::types::BinaryConstants* binaryvalues) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == nullptr) {
    delete binaryvalues_;
  }
  if (binaryvalues) {
    ::google::protobuf::Arena* submessage_arena = nullptr;
    if (message_arena != submessage_arena) {
      binaryvalues = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, binaryvalues, submessage_arena);
    }
    _has_bits_[0] |= 0x00000010u;
  } else {
    _has_bits_[0] &= ~0x00000010u;
  }
  binaryvalues_ = binaryvalues;
  // @@protoc_insertion_point(field_set_allocated:types.InNode.binaryValues)
}

// -------------------------------------------------------------------

// IntConstants

// repeated .types.IntNode intValues = 1;
inline int IntConstants::intvalues_size() const {
  return intvalues_.size();
}
inline void IntConstants::clear_intvalues() {
  intvalues_.Clear();
}
inline ::types::IntNode* IntConstants::mutable_intvalues(int index) {
  // @@protoc_insertion_point(field_mutable:types.IntConstants.intValues)
  return intvalues_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::types::IntNode >*
IntConstants::mutable_intvalues() {
  // @@protoc_insertion_point(field_mutable_list:types.IntConstants.intValues)
  return &intvalues_;
}
inline const ::types::IntNode& IntConstants::intvalues(int index) const {
  // @@protoc_insertion_point(field_get:types.IntConstants.intValues)
  return intvalues_.Get(index);
}
inline ::types::IntNode* IntConstants::add_intvalues() {
  // @@protoc_insertion_point(field_add:types.IntConstants.intValues)
  return intvalues_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::types::IntNode >&
IntConstants::intvalues() const {
  // @@protoc_insertion_point(field_list:types.IntConstants.intValues)
  return intvalues_;
}

// -------------------------------------------------------------------

// LongConstants

// repeated .types.LongNode longValues = 1;
inline int LongConstants::longvalues_size() const {
  return longvalues_.size();
}
inline void LongConstants::clear_longvalues() {
  longvalues_.Clear();
}
inline ::types::LongNode* LongConstants::mutable_longvalues(int index) {
  // @@protoc_insertion_point(field_mutable:types.LongConstants.longValues)
  return longvalues_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::types::LongNode >*
LongConstants::mutable_longvalues() {
  // @@protoc_insertion_point(field_mutable_list:types.LongConstants.longValues)
  return &longvalues_;
}
inline const ::types::LongNode& LongConstants::longvalues(int index) const {
  // @@protoc_insertion_point(field_get:types.LongConstants.longValues)
  return longvalues_.Get(index);
}
inline ::types::LongNode* LongConstants::add_longvalues() {
  // @@protoc_insertion_point(field_add:types.LongConstants.longValues)
  return longvalues_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::types::LongNode >&
LongConstants::longvalues() const {
  // @@protoc_insertion_point(field_list:types.LongConstants.longValues)
  return longvalues_;
}

// -------------------------------------------------------------------

// StringConstants

// repeated .types.StringNode stringValues = 1;
inline int StringConstants::stringvalues_size() const {
  return stringvalues_.size();
}
inline void StringConstants::clear_stringvalues() {
  stringvalues_.Clear();
}
inline ::types::StringNode* StringConstants::mutable_stringvalues(int index) {
  // @@protoc_insertion_point(field_mutable:types.StringConstants.stringValues)
  return stringvalues_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::types::StringNode >*
StringConstants::mutable_stringvalues() {
  // @@protoc_insertion_point(field_mutable_list:types.StringConstants.stringValues)
  return &stringvalues_;
}
inline const ::types::StringNode& StringConstants::stringvalues(int index) const {
  // @@protoc_insertion_point(field_get:types.StringConstants.stringValues)
  return stringvalues_.Get(index);
}
inline ::types::StringNode* StringConstants::add_stringvalues() {
  // @@protoc_insertion_point(field_add:types.StringConstants.stringValues)
  return stringvalues_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::types::StringNode >&
StringConstants::stringvalues() const {
  // @@protoc_insertion_point(field_list:types.StringConstants.stringValues)
  return stringvalues_;
}

// -------------------------------------------------------------------

// BinaryConstants

// repeated .types.BinaryNode binaryValues = 1;
inline int BinaryConstants::binaryvalues_size() const {
  return binaryvalues_.size();
}
inline void BinaryConstants::clear_binaryvalues() {
  binaryvalues_.Clear();
}
inline ::types::BinaryNode* BinaryConstants::mutable_binaryvalues(int index) {
  // @@protoc_insertion_point(field_mutable:types.BinaryConstants.binaryValues)
  return binaryvalues_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::types::BinaryNode >*
BinaryConstants::mutable_binaryvalues() {
  // @@protoc_insertion_point(field_mutable_list:types.BinaryConstants.binaryValues)
  return &binaryvalues_;
}
inline const ::types::BinaryNode& BinaryConstants::binaryvalues(int index) const {
  // @@protoc_insertion_point(field_get:types.BinaryConstants.binaryValues)
  return binaryvalues_.Get(index);
}
inline ::types::BinaryNode* BinaryConstants::add_binaryvalues() {
  // @@protoc_insertion_point(field_add:types.BinaryConstants.binaryValues)
  return binaryvalues_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::types::BinaryNode >&
BinaryConstants::binaryvalues() const {
  // @@protoc_insertion_point(field_list:types.BinaryConstants.binaryValues)
  return binaryvalues_;
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace types

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::types::GandivaType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::types::GandivaType>() {
  return ::types::GandivaType_descriptor();
}
template <> struct is_proto_enum< ::types::DateUnit> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::types::DateUnit>() {
  return ::types::DateUnit_descriptor();
}
template <> struct is_proto_enum< ::types::TimeUnit> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::types::TimeUnit>() {
  return ::types::TimeUnit_descriptor();
}
template <> struct is_proto_enum< ::types::SelectionVectorType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::types::SelectionVectorType>() {
  return ::types::SelectionVectorType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // PROTOBUF_INCLUDED_Types_2eproto
